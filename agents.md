
## 0) Главный Источник истины
 **Источник истины:** всегда начинать с чтения `docs/brief.md`. Любые расхождения решаются в пользу брифа. Если бриф обновился — выполнить цикл *Re‑Sync*:
1. Вычислить diff между текущими контрактами и `brief.md`.
2. Проставить метки `breaking / non‑breaking`.
3. Обновить `openapi.yaml`, `schemas/*`, описания провайдеров.
4. Перегенерировать стабы и тесты.
5. Запустить все тесты; приложить отчёт.


## 0.1) Roadmap спецификаций

* Обязательный артефакт: `spec/roadmap.md`. Содержит последовательность задач по подготовке полного пакета спецификаций.
* Работать строго по порядку задач из этого файла. После завершения каждого шага обновлять статус внутри роадмапа.

## 1) Миссия и границы

* **Миссия:** разрабатывать и сопровождать проекты строго по **Spec‑Driven Development**: сначала спецификации и контракты, затем реализация.
* **Границы:** агент **не** вносит изменения в код без подтверждённой спецификации/контрактов. При существенных рисках — **останавливается** и задаёт уточняющие вопросы.
* **Целевые стеки по умолчанию:**

  * Backend: **Python FastAPI** (ASGI), синхронные ручки там, где можно, фоновые задачи через встроенные механизмы/процессы.
  * Frontend: **HTMX + VanillaJS**, без SPA‑фреймворков по умолчанию. При необходимости реактивности Alpine.js
  * Хранение артефактов спецификаций: Markdown + Mermaid, JSON Schema, OpenAPI.
* **Ограничения:** по возможности **избегать npm‑зависимостей** и тяжёлых библиотек. Предпочтение – стандартной библиотеке, небольшим, зрелым зависимостям.

---

## 2) Принципы архитектуры

1. **Contract‑first:** OpenAPI/JSON Schema → затем реализация. Любое несоответствие кода контрактам — критическая ошибка.
2. **Low coupling / High cohesion:** каждый модуль делает одно; коммуникация через чёткие интерфейсы/контракты; минимум знание о соседях.
3. **Тонкие фасады:** транспортные слои (HTTP, CLI) — тонкие адаптеры, вся логика в домене.
4. **Модульность и малые файлы:** предпочитать короткие файлы/функции, явную декомпозицию.
5. **Обратимость решений:** ADR фиксирует выбор; при новых фактах — доп. ADR и рефакторинг через миграционные шаги.
6. **Проактивная безопасность:** явные лимиты ввода, валидация схемой, канонизация данных, принцип наименьших привилегий.

---

## 3) SDD‑процесс (канонический)

1. **Brief → Issues (EPIC/Feature/Task).**
2. **Контракты:**

   * JSON Schema для входов/выходов/сущностей.
   * OpenAPI (минимально необходимый скоуп).
3. **NFR:** производительность, безопасность, наблюдаемость, долговечность API, ограничения окружений.
4. **Use‑cases:** сценарии с предусловиями/постусловиями, альтернативными ветками, ошибками.
5. **Последовательности:** диаграммы (Mermaid sequence/activity) для ключевых потоков.
6. **Domain design:** словарь терминов, агрегаты, сервисы, порты/адаптеры.
7. **Acceptance Criteria + Test Plan:** BDD‑стиль кратко, примеры вход/выход.
8. **Skeleton → Adapters → Domain:** тонкий каркас сервисов и ручек, затем доменная логика.
9. **Трейсинг несоответствий:** любые расхождения кода и контрактов — в Issues + PR‑комментарии, остановка действия.

**Папочная структура (рекомендуемая):**

```
/spec         # brief, NFR, use-cases, diagrams
/contracts    # openapi.yaml, *.schema.json
/adr          # архитектурные решения
/docs         # служебная дока
/src          # код (домены/порты/адаптеры)
/tests        # автотесты: unit, contract, e2e-lite
```

---

## 4) Политика рисков и стоп‑условия

Агент **останавливается** и запрашивает решение пользователя, если:

* Нельзя формально вывести контракт из брифа (нехватка данных/противоречия).
* Предложенная функция нарушает существующие NFR/контракты.
* Необходима тяжёлая зависимость (npm/большая библиотека), и нет явного согласия.
* Требуется небезопасная практика (хранение секретов в коде, отсутствие валидации и т. д.).
* Найденное решение задачи существенно увеличивает коплексность проекта, добавляет запутанность
* В архитектуре проекта найдены узкие места, которые могут привести к проблемам в последствии

При остановке агент публикует: **проблему → варианты → компромиссы → рекомендуемый план**.

---

## 5) Стиль кода и практики

* **Python (FastAPI):** type hints, pydantic/`Annotated`‑валидация, явные DTO, зависимостей минимум, чистые функции в домене.
* **HTMX + VanillaJS/Alpine.js:** прогрессивное улучшение, idempotent‑эндпоинты, частичные HTML‑фрагменты (Jinja2), серверные проверки.
* **Тесты:** при каждом PR — unit + contract. Допускается e2e‑lite через httpx/pytest + локальный ASGI.
* **Наблюдаемость:** логирование на уровне фасада + ключевые события домена.
* **Размеры:** функции до ~50 строк, файлы до ~200–300 строк, модули — малые и переиспользуемые.

---

## 6) Правила для Codex Cloud

* Перед началом: прочитать **AGENTS.md**, `/spec`, `/contracts`, `/adr`, затем весь модуль задачи.
* Соблюдать **prompting‑политику проекта**:

  * Всегда ссылаться на текущие контракты.
  * Логировать неудачные команды/тесты.
  * Предпочитать локальные инструменты и простые сценарии.
* PR‑политика: один PR = одна узкая цель; чек‑лист ниже.

---

## 7) Чек‑листы

**Перед реализацией:**

* [ ] Контракты полны и согласованы с брифом.
* [ ] NFR покрывают изменения.
* [ ] Диаграммы/Use‑cases обновлены.

**В PR:**

* [ ] Тесты зелёные (unit + contract).
* [ ] Код следует стилю (линтер/форматтер при наличии).
* [ ] Обновлены `/contracts`, `/spec`, `/docs` и ADR при изменениях решений.

**Перед слиянием:**

* [ ] Нет скрытых зависимостей/глобальных синглтонов.
* [ ] Интерфейсы стабильны; миграции задокументированы.

---

## 8) Команды (рекомендуемые)

```bash
# Локальный dev (пример):
uvicorn app.main:app --reload --host 127.0.0.1 --port 8000

# Контракт‑тесты (пример):
pytest -q -m contract

# Юнит‑тесты:
pytest -q -m unit
```

*(Команды являются рекомендательными; агент может адаптировать под конкретный проект.)*

---

## 9) Политика зависимостей

* Сначала — стандартная библиотека.
* Если внешняя зависимость неизбежна: краткое обоснование (размер, зрелость, лицензия, атаки цепочки поставок), сравнение ≥2 альтернатив, план отказа.

---

## 10) Документация артефактов

* Любая новая ручка/сущность → обновить **OpenAPI/JSON Schema** и **/spec**.
* Диаграммы Mermaid держать рядом со спецификациями.
* В README — только обзор; в **AGENTS.md** — правила для агента.

---

## 11) Эскалация и вопросы к пользователю

Если решения неоднозначны, агент задаёт компактный вопрос формата:

> **Вопрос:** …
> **Варианты:** A / B / C (последствия кратко)
> **Рекомендация:** …
> **Что выбрать?**

---

## 12) Мини‑шаблоны

**ADR N:** Решение / Контекст / Варианты / Причины выбора / Риски / Миграция.

**Use‑case:** Название / Акторы / Предусловия / Основной поток / Альтернативы / Ошибки / Постусловия.

**Acceptance Criteria (пример):**

* [ ] При POST `/api/v1/items` валиден body по `Item.schema.json` → 201 + payload по `Item.schema.json`.
* [ ] При нарушении схемы → 422 с детальным перечнем ошибок.

---

## 13) Лицензии и соответствие

* Учитывать совместимость лицензий зависимостей.
* Не включать в репозиторий секреты/персональные данные.

---

## 14) Антипаттерны (запрещено)

* Скрытая бизнес‑логика во фронтенд‑скриптах.
* Жёсткие связи между адаптерами и доменом.
* Необоснованные глобальные синглтоны/магические состояния.
* «Временные» флаги без сроков удаления/ADR.

---

## 15) Завершение задач

* Каждый PR сопровождается обновлением контрактов и спецификаций.
* В описании PR: цель, ссылка на спецификацию/ADR, влияние на API/данные, риски, план отката.
* После слияния: короткий changelog и TODO для следующего итерационного шага.
