import{r as A,c as v,a as I,b as V,t as q,d as z,e as J,f as Q}from"../assets/chrome-CDKoC93C.js";import{S as k,l as tt,g as et}from"../assets/messages-B9y2QbG0.js";function at(){return"codex.tasks.state"}const N=12e3,W=15e3,nt=3,O=at(),B=3,st=1e3;function ot(e={}){return new rt(e)}class rt{constructor(t){this.state=T(M),this.listeners=new Set,this.chrome=t.chrome??A();const a=t.logger??v("codex-background");this.logger=I(a,"aggregator"),this.now=t.now??(()=>Date.now()),this.ready=this.loadInitialState()}onStateChange(t){return this.listeners.add(t),()=>{this.listeners.delete(t)}}async getSnapshot(){return await this.ready,T(this.state)}async getTrackedTabIds(){return await this.ready,Object.keys(this.state.tabs).map(t=>Number(t))}async handleTasksUpdate(t,a){var s;await this.ready;const n=(s=a.tab)==null?void 0:s.id;if(typeof n!="number"){this.logger.warn("TASKS_UPDATE without tab id",{message:t});return}await this.updateState("tasks-update",(o,d)=>{const u=String(n),h=this.resolveTitle(a,t.origin),g=Object.prototype.hasOwnProperty.call((d==null?void 0:d.tabs)??{},u),r=o.tabs[u]??this.createTabState(t.origin,h,t.ts);let i=!g;r.origin!==t.origin&&(r.origin=t.origin,i=!0),r.title!==h&&(r.title=h,i=!0),r.count!==t.count&&(r.count=t.count,i=!0),r.active!==t.active&&(r.active=t.active,i=!0),r.updatedAt!==t.ts&&(r.updatedAt=t.ts,i=!0);const c=r.heartbeat,l=Math.max(c.lastReceivedAt,t.ts);c.lastReceivedAt!==l&&(c.lastReceivedAt=l,i=!0),c.status!=="OK"&&(c.status="OK",i=!0),c.missedCount!==0&&(c.missedCount=0,i=!0);const f=Math.max(l,r.lastSeenAt,t.ts);r.lastSeenAt!==f&&(r.lastSeenAt=f,i=!0);const m=t.signals.map(b=>({...b}));ut(r.signals,m)||(r.signals=m,i=!0),o.tabs[u]=r;const y=K(o.tabs);o.lastTotal!==y&&(o.lastTotal=y,i=!0);const x=(d==null?void 0:d.lastTotal)??0;return i=this.applyDebounceTransition(o,x)||i,i},{tabId:n}),this.logger.debug("TASKS_UPDATE processed",{tabId:n,count:t.count,active:t.active})}async handleHeartbeat(t,a){var s;await this.ready;const n=(s=a.tab)==null?void 0:s.id;if(typeof n!="number"){this.logger.warn("TASKS_HEARTBEAT without tab id",{message:t});return}await this.updateState("heartbeat",(o,d)=>{const u=String(n),h=this.resolveTitle(a,t.origin),g=Math.max(0,t.ts),r=Math.max(g,t.lastUpdateTs),i=Object.prototype.hasOwnProperty.call((d==null?void 0:d.tabs)??{},u),c=o.tabs[u]??this.createTabState(t.origin,h,r);let l=!i;c.origin!==t.origin&&(c.origin=t.origin,l=!0),c.title!==h&&(c.title=h,l=!0),c.updatedAt<r&&(c.updatedAt=r,l=!0);const f=c.heartbeat,m=$(t.intervalMs);f.expectedIntervalMs!==m&&(f.expectedIntervalMs=m,l=!0),f.lastReceivedAt!==g&&(f.lastReceivedAt=g,l=!0),f.status!=="OK"&&(f.status="OK",l=!0),f.missedCount!==0&&(f.missedCount=0,l=!0);const y=Math.max(c.lastSeenAt,g,c.updatedAt);return c.lastSeenAt!==y&&(c.lastSeenAt=y,l=!0),o.tabs[u]=c,l},{tabId:n}),this.logger.debug("TASKS_HEARTBEAT processed",{tabId:n,intervalMs:t.intervalMs})}async handleTabRemoved(t){await this.ready,await this.updateState("tab-removed",a=>{const n=String(t);if(!(n in a.tabs))return!1;delete a.tabs[n];const s=K(a.tabs);return a.lastTotal!==s&&(a.lastTotal=s),s===0&&a.debounce.since!==0&&(a.debounce.since=0),!0},{tabId:t}),this.logger.info("tab removed",{tabId:t})}async evaluateHeartbeatStatuses(){await this.ready;const t=[];return await this.updateState("heartbeat-stale",a=>{let n=!1;const s=this.now();for(const[o,d]of Object.entries(a.tabs)){const{heartbeat:u}=d,h=u.expectedIntervalMs*nt;s-u.lastReceivedAt>=h&&(t.push(Number(o)),u.status="STALE",u.missedCount+=1,n=!0)}return n},{staleTabIds:[...t]}),t.length>0&&this.logger.warn("heartbeat stale detected",{tabIds:t}),t}async clearDebounceIfIdle(){await this.ready;let t=!1;return await this.updateState("debounce-cleared",a=>a.debounce.since===0?!1:a.lastTotal===0&&dt(a.tabs)?(a.debounce.since=0,t=!0,!0):!1),t&&this.logger.info("debounce window cleared"),t}async loadInitialState(){try{const a=(await this.chrome.storage.session.get({[O]:M}))[O];if(a)try{V(a),this.state=T(it(a)),this.logger.info("restored aggregated state",{tabs:Object.keys(this.state.tabs).length,lastTotal:this.state.lastTotal}),this.notifyListeners({reason:"init",previous:T(M),current:T(this.state)});return}catch(n){this.logger.warn("stored state invalid, resetting",n)}}catch(t){this.logger.error("failed to read storage",t)}this.state=T(M),await this.persistState(this.state),this.notifyListeners({reason:"init",previous:T(M),current:T(this.state)})}async updateState(t,a,n={}){const s=T(this.state),o=T(this.state);a(o,s)&&(Z(o.debounce),V(o),await this.persistState(o),this.state=o,this.notifyListeners({reason:t,previous:s,current:T(this.state),...n}))}async persistState(t){const a={[O]:t};let n=0;for(;n<B;)try{await this.chrome.storage.session.set(a);return}catch(s){if(n+=1,this.logger.warn("failed to write state",{attempt:n,error:s}),n>=B)throw s;await ht(st)}}notifyListeners(t){for(const a of Array.from(this.listeners))try{a({...t,previous:T(t.previous),current:T(t.current),staleTabIds:t.staleTabIds?[...t.staleTabIds]:void 0})}catch(n){this.logger.error("listener threw",n)}}applyDebounceTransition(t,a){const n=this.now();if(t.lastTotal===0){if(a>0&&t.debounce.since===0)return t.debounce.since=n,!0}else if(t.debounce.since!==0)return t.debounce.since=0,!0;return!1}resolveTitle(t,a){var o;const s=(((o=t.tab)==null?void 0:o.title)??"").trim();return s.length>0?s:a}createTabState(t,a,n){const s=Math.max(0,n);return{origin:t,title:a,count:0,active:!1,updatedAt:s,lastSeenAt:s,heartbeat:{lastReceivedAt:s,expectedIntervalMs:W,status:"OK",missedCount:0}}}}const M={tabs:{},lastTotal:0,debounce:{ms:N,since:0}};function Z(e){(typeof e.ms!="number"||Number.isNaN(e.ms))&&(e.ms=N),e.ms=Math.min(Math.max(e.ms,0),6e4),(typeof e.since!="number"||Number.isNaN(e.since)||e.since<0)&&(e.since=0)}function it(e){var a,n;const t={tabs:{},lastTotal:Math.max(0,e.lastTotal??0),debounce:{ms:((a=e.debounce)==null?void 0:a.ms)??N,since:((n=e.debounce)==null?void 0:n.since)??0}};for(const[s,o]of Object.entries(e.tabs??{}))t.tabs[s]=ct(o);return Z(t.debounce),t}function ct(e){return{origin:e.origin,title:e.title,count:Math.max(0,e.count??0),active:!!e.active,updatedAt:e.updatedAt,lastSeenAt:e.lastSeenAt,heartbeat:lt(e.heartbeat),...e.signals?{signals:e.signals.map(t=>({...t}))}:{}}}function lt(e){return{lastReceivedAt:e.lastReceivedAt,expectedIntervalMs:$(e.expectedIntervalMs),status:e.status==="STALE"?"STALE":"OK",missedCount:Math.max(0,e.missedCount??0)}}function T(e){const t={};for(const[a,n]of Object.entries(e.tabs))t[a]={origin:n.origin,title:n.title,count:n.count,active:n.active,updatedAt:n.updatedAt,lastSeenAt:n.lastSeenAt,heartbeat:{...n.heartbeat},...n.signals?{signals:n.signals.map(s=>({...s}))}:{}};return{tabs:t,lastTotal:e.lastTotal,debounce:{...e.debounce}}}function K(e){return Object.values(e).reduce((t,a)=>t+a.count,0)}function dt(e){return Object.values(e).every(t=>t.count===0)}function ut(e,t){return!e&&!t?!0:!e||!t||e.length!==t.length?!1:e.every((a,n)=>{const s=t[n];return a.detector===s.detector&&a.evidence===s.evidence&&a.taskKey===s.taskKey})}function $(e){return Number.isFinite(e)?Math.min(Math.max(Math.trunc(e),1e3),6e4):W}function ht(e){return new Promise(t=>{setTimeout(t,e)})}function U(e){var n,s,o;return(((s=(n=(e??A()).i18n)==null?void 0:n.getUILanguage)==null?void 0:s.call(n))??((o=globalThis.navigator)==null?void 0:o.language)??"en").toLowerCase().startsWith("ru")?"ru":"en"}const ft=[0,0,0,0],gt=200,P=9,H=[16,24,32],bt=.92,D=[{threshold:0,color:"#16A34A"},{threshold:1,color:"#F97316"},{threshold:2,color:"#F2542D"},{threshold:3,color:"#E11D48"},{threshold:4,color:"#C2185B"}],j={en:e=>`${e} active Codex tasks`,ru:e=>`${e} активных задач Codex`};function mt(e,t={}){const a=t.chrome??A(),n=a.action,s=t.logger??v("codex-background"),o=I(s,"action-indicator");if(!n)return o.warn("chrome.action API is unavailable; badge indicator disabled"),{dispose(){}};let d=!1;const u=U(a),h=j[u]??j.en,g=X();g||o.debug("OffscreenCanvas/ImageData unavailable; falling back to badge text");const r=q(async l=>{if(d)return;const f=Tt(l.lastTotal??0);if(await c(()=>n.setBadgeBackgroundColor({color:ft})),await c(()=>n.setBadgeText({text:""})),n.setTitle&&await c(()=>n.setTitle({title:h(f.text)})),g&&n.setIcon){const m=pt(f.text,f.color,o);m&&await c(()=>n.setIcon({imageData:m}))}else n.setBadgeTextColor&&(await c(()=>n.setBadgeTextColor({color:f.color})),await c(()=>n.setBadgeText({text:f.text})))},gt),i=e.onStateChange(l=>{r(l.current)});return e.ready.then(()=>e.getSnapshot()).then(l=>r(l)).catch(l=>{o.error("failed to apply initial badge state",l)}),{dispose(){var l;d=!0,i(),(l=r.cancel)==null||l.call(r)}};async function c(l){try{await l()}catch(f){o.warn("action API call failed",f)}}}function Tt(e){const t=Number.isFinite(e)?Math.max(0,Math.trunc(e)):0,a=t>P?String(P):String(t),n=St(t);return{text:a,color:n}}function St(e){for(let t=D.length-1;t>=0;t-=1){const a=D[t];if(e>=a.threshold)return a.color}return D[0].color}function X(){return typeof OffscreenCanvas<"u"&&typeof ImageData<"u"}function pt(e,t,a){if(X())try{const n={};for(const s of H)n[s]=yt(s,e,t);return n}catch(n){return a.warn("failed to render text icon, falling back to transparent icon",n),At(H)}}function yt(e,t,a){const s=new OffscreenCanvas(e,e).getContext("2d");if(!s)throw new Error("OffscreenCanvas context unavailable");s.clearRect(0,0,e,e),s.fillStyle=a,s.textAlign="center",s.textBaseline="middle";const o=Math.floor(e*bt);s.font=`900 ${o}px "Inter","Segoe UI","Roboto",sans-serif`,s.lineJoin="round";const d=Math.max(1,Math.floor(e*.08));return s.strokeStyle="rgba(0,0,0,0.08)",s.lineWidth=d,s.strokeText(t,e/2,e/2),s.fillText(t,e/2,e/2),s.getImageData(0,0,e,e)}function At(e){const t={};for(const a of e)t[a]=wt(a);return t}function wt(e){const t=e*e*4,a=new Uint8ClampedArray(t);return new ImageData(a,e,e)}function vt(e,t={}){const a=t.chrome??A(),n=I(t.logger??v("codex-background"),"audio-trigger"),s=new It(e,a,n);return{dispose(){s.dispose()}}}class It{constructor(t,a,n){this.aggregator=t,this.chrome=a,this.logger=n,this.disposed=!1,this.soundEnabled=k.sound,this.soundVolume=k.soundVolume,this.settingsInitialized=!1,this.unsubscribe=t.onStateChange(s=>{this.handleStateChange(s)}),this.storageListener=(s,o)=>{if(this.disposed||o!=="sync")return;const d={},u=s.sound;u&&typeof u.newValue=="boolean"&&(d.sound=u.newValue);const h=s.soundVolume;h&&typeof h.newValue=="number"&&(d.soundVolume=h.newValue),Object.keys(d).length>0&&this.applySettings(d)},this.chrome.storage.onChanged.addListener(this.storageListener),t.ready.catch(s=>{this.logger.warn("failed to init audio trigger state",s)}),this.refreshSettings()}dispose(){this.disposed||(this.disposed=!0,this.unsubscribe(),this.chrome.storage.onChanged.removeListener(this.storageListener))}async refreshSettings(){try{const t=await tt(this.chrome);this.applySettings({sound:t.sound,soundVolume:t.soundVolume})}catch(t){this.logger.debug("failed to load audio settings",t)}}applySettings(t){let a=!this.settingsInitialized;if(typeof t.sound=="boolean"&&t.sound!==this.soundEnabled&&(this.soundEnabled=t.sound,a=!0),typeof t.soundVolume=="number"){const n=F(t.soundVolume);n!==this.soundVolume&&(this.soundVolume=n,a=!0)}this.settingsInitialized=!0,a&&this.broadcastSettingsUpdate()}async handleStateChange(t){if(this.disposed)return;const a=t.previous.lastTotal??0,n=t.current.lastTotal??0;a>0&&n===0&&await this.broadcastAudioChime()}async broadcastSettingsUpdate(){const t={type:"AUDIO_SETTINGS_UPDATE",sound:this.soundEnabled,soundVolume:this.soundVolume};await this.sendRuntimeMessage(t),await this.sendTabMessages(t)}async broadcastAudioChime(){if(!this.soundEnabled)return;const t=F(this.soundVolume);if(t<=0)return;const a={type:"AUDIO_CHIME",volume:t};await this.sendRuntimeMessage(a),await this.sendTabMessages(a)}async sendRuntimeMessage(t){try{await this.chrome.runtime.sendMessage(t)}catch(a){this.logger.debug("runtime audio message failed",a)}}async sendTabMessages(t){try{const a=await this.aggregator.getTrackedTabIds();await Promise.all(a.map(async n=>{try{await this.chrome.tabs.sendMessage(n,t)}catch(s){this.logger.debug("audio tab message failed",{tabId:n,error:s})}}))}catch(a){this.logger.debug("audio tab broadcast failed",a)}}}function F(e){return Number.isFinite(e)?e<=0?0:e>=1?1:e:k.soundVolume}async function Et(e,t={}){var i;const a=await e.getSnapshot(),n=t.chrome??A(),s=t.locale??U(n),o=((i=t.now)==null?void 0:i.call(t))??Date.now(),d=new Date(o).toISOString(),u=Ct(a).filter(c=>c.count>0);u.sort((c,l)=>{if(l.count!==c.count)return l.count-c.count;const f=c.lastSeenAt??0,m=l.lastSeenAt??0;return m!==f?m-f:l.tabId-c.tabId});const h=Math.max(0,u.reduce((c,l)=>c+l.count,0)),g={...et(s)},r={generatedAt:d,totalActive:h,tabs:u,locale:s,messages:g};return z(r),r}function Ct(e){const t=[];for(const[a,n]of Object.entries(e.tabs)){const s=Number(a);Number.isFinite(s)&&t.push({tabId:s,title:n.title,origin:n.origin,count:Math.max(0,n.count),lastSeenAt:n.lastSeenAt,heartbeatStatus:n.heartbeat.status,signals:n.signals?n.signals.map(o=>({...o})):[]})}return t}const _="codex-poll",G=1;function Mt(e,t={}){const a=t.chrome??A(),n=t.logger??v("codex-background"),s=I(n,"alarms");a.alarms.create(_,{periodInMinutes:G}),s.info("alarm scheduled",{name:_,periodMinutes:G});const o=new Set,d=e.onStateChange(r=>{h(r.current).catch(i=>{s.warn("failed to enforce autoDiscardable",i)}),r.reason==="tab-removed"&&typeof r.tabId=="number"&&o.delete(r.tabId)});e.ready.then(()=>e.getSnapshot()).then(r=>h(r)).catch(r=>{s.error("failed to apply autoDiscardable on startup",r)}),e.getSnapshot().then(r=>h(r)).catch(r=>{s.warn("failed to apply autoDiscardable on initial snapshot",r)});const u=r=>{r.name===_&&g().catch(i=>{s.error("alarm tick failed",i)})};return a.alarms.onAlarm.addListener(u),{dispose(){a.alarms.onAlarm.removeListener(u),d(),o.clear()}};async function h(r){for(const i of Object.keys(r.tabs).map(Number))if(!o.has(i))try{await a.tabs.update(i,{autoDiscardable:!1}),o.add(i),s.debug("autoDiscardable disabled",{tabId:i})}catch(c){s.warn("autoDiscardable update failed",{tabId:i,error:c})}for(const i of Array.from(o))r.tabs[String(i)]||o.delete(i)}async function g(){s.debug("alarm tick");const r=await e.evaluateHeartbeatStatuses();if(r.length!==0)for(const i of r)try{await a.tabs.sendMessage(i,{type:"PING"}),s.info("ping sent to tab",{tabId:i})}catch(c){s.warn("failed to ping tab",{tabId:i,error:c})}}}const Y="codex-tasks-zero",xt={en:{title:"Codex",message:"All Codex tasks are complete",buttonOk:"OK"},ru:{title:"Codex",message:"Все задачи Codex завершены",buttonOk:"ОК"}};function Lt(e,t={}){const a=t.chrome??A(),n=t.logger??v("codex-background"),s=I(n,"notifications"),o=t.now??(()=>Date.now()),d=U(a),u=xt[d];let h=!1,g,r=0,i;const c=e.onStateChange(b=>{h||l(b.current).catch(p=>{s.error("state change handling failed",p)})});return e.ready.then(()=>e.getSnapshot()).then(b=>l(b)).catch(b=>{s.error("failed to read initial state",b)}),{dispose(){h=!0,g&&(clearTimeout(g),g=void 0),r=0,c()}};async function l(b){if(!h){if(b.lastTotal>0){m(),await x();return}if(b.debounce.since===0){m();return}f(b)}}function f(b){const p=b.debounce.since+b.debounce.ms,L=o();if(L>=p){y();return}if(g&&r===p)return;m();const C=Math.max(0,p-L);r=p,g=setTimeout(()=>{g=void 0,r=0,y()},C),s.debug("debounce timer scheduled",{delay:C,target:p})}function m(){g&&(clearTimeout(g),g=void 0),r=0}async function y(){if(h)return;const b=await e.getSnapshot();if(b.debounce.since===0){s.debug("debounce window already cleared");return}const p=b.debounce.since+b.debounce.ms;if(o()<p){s.debug("debounce window not ready yet"),f(b);return}if(b.lastTotal!==0||!Ot(b)){s.info("activity detected during debounce, skipping notification"),m();return}try{i=await a.notifications.create(Y,{type:"basic",title:u.title,message:u.message,iconUrl:"assets/icon128.png",buttons:[{title:u.buttonOk}]})??Y,s.info("notification created",{notificationId:i})}catch(C){s.error("failed to create notification",C)}finally{m(),await e.clearDebounceIfIdle()}}async function x(){if(i){try{await a.notifications.clear(i),s.debug("notification cleared",{notificationId:i})}catch(b){s.warn("failed to clear notification",b)}i=void 0}}}function Ot(e){return Object.values(e.tabs).every(t=>t.count===0)}const R="codex.tasks.verbose",w=A(),{logger:S}=_t(w),E=ot({chrome:w,logger:S});Lt(E,{chrome:w,logger:S});mt(E,{chrome:w,logger:S});vt(E,{chrome:w,logger:S});Mt(E,{chrome:w,logger:S});w.runtime.onMessage.addListener((e,t,a)=>(Dt(E,I(S,"runtime"),e,t).then(n=>{try{a(n)}catch(s){S.warn("sendResponse failed",s)}}).catch(n=>{S.error("message handling failed",n);try{a(void 0)}catch(s){S.warn("sendResponse failed",s)}}),!0));w.tabs.onRemoved.addListener(e=>{E.handleTabRemoved(e).catch(t=>{S.error("tab removal handling failed",{tabId:e,error:t})})});async function Dt(e,t,a,n){if(!a||typeof a!="object")return;const{type:s}=a;if(s==="TASKS_UPDATE"){try{J(a)}catch(o){t.warn("invalid TASKS_UPDATE payload",o);return}await e.handleTasksUpdate(a,n);return}if(s==="TASKS_HEARTBEAT"){try{Q(a)}catch(o){t.warn("invalid TASKS_HEARTBEAT payload",o);return}await e.handleHeartbeat(a,n);return}if(s==="POPUP_GET_STATE"){const o=await Et(e);return t.debug("popup state generated",{totalActive:o.totalActive}),o}t.debug("unknown message type ignored",{type:s})}function _t(e){let t=!1;const n=v("codex-background",{debug:(...o)=>{t&&console.debug(...o)},info:(...o)=>console.info(...o),warn:(...o)=>console.warn(...o),error:(...o)=>console.error(...o)});s(),e.storage.onChanged.addListener((o,d)=>{if(d!=="session")return;const u=o[R];if(!u)return;const h=!!u.newValue;h!==t&&(t=h,n.info("verbose flag toggled",{verbose:t}))});async function s(){try{const d=!!(await e.storage.session.get({[R]:!1}))[R];d!==t&&(t=d,n.info("verbose flag toggled",{verbose:t}))}catch(o){console.warn("failed to read verbose flag",o)}}return{logger:n}}
