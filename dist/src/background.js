import{r as I,c as D,a as O,b as K,t as et,d as at,e as st,f as nt}from"../assets/chrome-CWUhAqIv.js";import{c as x}from"../assets/url-BvzPlvhJ.js";import{S as C,l as W,g as it,n as rt}from"../assets/messages-D57IxLg4.js";function ot(){return"codex.tasks.state"}const _=C.debounceMs,Z=15e3,ct=3,V=ot(),j=3,lt=1e3;function dt(e={}){return new ut(e)}class ut{constructor(t){var a;this.state=w(R),this.listeners=new Set,this.idleListeners=new Set,this.idleTarget=0,this.chrome=t.chrome??I();const s=t.logger??D("codex-background");this.logger=O(s,"aggregator"),this.now=t.now??(()=>Date.now()),this.settings=t.settings,this.ready=this.initialize(),(a=this.settings)==null||a.onChange(n=>{this.applyDebounceDuration(n.debounceMs)})}onStateChange(t){return this.listeners.add(t),()=>{this.listeners.delete(t)}}onIdleSettled(t){return this.idleListeners.add(t),()=>{this.idleListeners.delete(t)}}async getSnapshot(){return await this.ready,w(this.state)}async getTrackedTabIds(){return await this.ready,Object.keys(this.state.tabs).map(t=>Number(t))}async handleTasksUpdate(t,s){var n;await this.ready;const a=(n=s.tab)==null?void 0:n.id;if(typeof a!="number"){this.logger.warn("TASKS_UPDATE without tab id",{message:t});return}await this.updateState("tasks-update",(i,r)=>{const c=String(a),u=Object.prototype.hasOwnProperty.call((r==null?void 0:r.tabs)??{},c),g=x(t.origin);if(!!!(g!=null&&g.isTasksListing||g!=null&&g.isTaskDetails)){let S=!1;c in i.tabs&&(delete i.tabs[c],S=!0);const L=k(i.tabs);i.lastTotal!==L&&(i.lastTotal=L,S=!0);const tt=(r==null?void 0:r.lastTotal)??0;return S=this.applyDebounceTransition(i,tt)||S,L===0&&i.debounce.since!==0&&E(i.tabs)&&(i.debounce.since=0,S=!0),S}const T=this.resolveTitle(s,t.origin),d=i.tabs[c]??this.createTabState(t.origin,T,t.ts);let l=!u;d.origin!==t.origin&&(d.origin=t.origin,l=!0),d.title!==T&&(d.title=T,l=!0),d.count!==t.count&&(d.count=t.count,l=!0),d.active!==t.active&&(d.active=t.active,l=!0),d.updatedAt!==t.ts&&(d.updatedAt=t.ts,l=!0);const f=d.heartbeat,o=Math.max(f.lastReceivedAt,t.ts);f.lastReceivedAt!==o&&(f.lastReceivedAt=o,l=!0),f.status!=="OK"&&(f.status="OK",l=!0),f.missedCount!==0&&(f.missedCount=0,l=!0);const h=Math.max(o,d.lastSeenAt,t.ts);d.lastSeenAt!==h&&(d.lastSeenAt=h,l=!0);const m=t.signals.map(S=>({...S}));bt(d.signals,m)||(d.signals=m,l=!0),i.tabs[c]=d;const b=k(i.tabs);i.lastTotal!==b&&(i.lastTotal=b,l=!0);const p=(r==null?void 0:r.lastTotal)??0;return l=this.applyDebounceTransition(i,p)||l,l},{tabId:a}),this.logger.debug("TASKS_UPDATE processed",{tabId:a,count:t.count,active:t.active})}async handleHeartbeat(t,s){var n;await this.ready;const a=(n=s.tab)==null?void 0:n.id;if(typeof a!="number"){this.logger.warn("TASKS_HEARTBEAT without tab id",{message:t});return}await this.updateState("heartbeat",(i,r)=>{const c=String(a),u=Object.prototype.hasOwnProperty.call((r==null?void 0:r.tabs)??{},c),g=x(t.origin);if(!!!(g!=null&&g.isTasksListing||g!=null&&g.isTaskDetails)){let p=!1;c in i.tabs&&(delete i.tabs[c],p=!0);const S=k(i.tabs);i.lastTotal!==S&&(i.lastTotal=S,p=!0);const L=(r==null?void 0:r.lastTotal)??0;return p=this.applyDebounceTransition(i,L)||p,S===0&&i.debounce.since!==0&&E(i.tabs)&&(i.debounce.since=0,p=!0),p}const T=this.resolveTitle(s,t.origin),d=Math.max(0,t.ts),l=Math.max(d,t.lastUpdateTs),f=i.tabs[c]??this.createTabState(t.origin,T,l);let o=!u;f.origin!==t.origin&&(f.origin=t.origin,o=!0),f.title!==T&&(f.title=T,o=!0),f.updatedAt<l&&(f.updatedAt=l,o=!0);const h=f.heartbeat,m=q(t.intervalMs);h.expectedIntervalMs!==m&&(h.expectedIntervalMs=m,o=!0),h.lastReceivedAt!==d&&(h.lastReceivedAt=d,o=!0),h.status!=="OK"&&(h.status="OK",o=!0),h.missedCount!==0&&(h.missedCount=0,o=!0);const b=Math.max(f.lastSeenAt,d,f.updatedAt);return f.lastSeenAt!==b&&(f.lastSeenAt=b,o=!0),i.tabs[c]=f,o},{tabId:a}),this.logger.debug("TASKS_HEARTBEAT processed",{tabId:a,intervalMs:t.intervalMs})}async handleTabRemoved(t){await this.ready,Object.prototype.hasOwnProperty.call(this.state.tabs,String(t))&&await this.dropTabState(t,"tab-removed","tab removed")}async handleTabNavigated(t){await this.ready,Object.prototype.hasOwnProperty.call(this.state.tabs,String(t))&&await this.dropTabState(t,"tab-navigated","tab navigated away")}async evaluateHeartbeatStatuses(){await this.ready;const t=[];return await this.updateState("heartbeat-stale",s=>{let a=!1;const n=this.now();for(const[i,r]of Object.entries(s.tabs)){const{heartbeat:c}=r,u=c.expectedIntervalMs*ct;n-c.lastReceivedAt>=u&&(t.push(Number(i)),c.status="STALE",c.missedCount+=1,a=!0)}return a},{staleTabIds:[...t]}),t.length>0&&this.logger.warn("heartbeat stale detected",{tabIds:t}),t}async dropTabState(t,s,a){await this.ready;let n=!1;if(await this.updateState(s,(i,r)=>{const c=String(t);if(!(c in i.tabs))return!1;n=!0,delete i.tabs[c];const u=k(i.tabs);i.lastTotal!==u&&(i.lastTotal=u);const g=(r==null?void 0:r.lastTotal)??0;return this.applyDebounceTransition(i,g),u===0&&i.debounce.since!==0&&E(i.tabs)&&(i.debounce.since=0),!0},{tabId:t}),n){this.logger.info(a,{tabId:t});return}this.logger.debug("dropTabState skipped for untracked tab",{tabId:t,reason:s})}async initialize(){if(await this.loadInitialState(),this.settings)try{await this.settings.ready;const t=this.settings.getSnapshot();await this.applyDebounceDuration(t.debounceMs)}catch(t){this.logger.warn("failed to apply settings during init",t),await this.applyDebounceDuration(_)}else await this.applyDebounceDuration(_);this.refreshIdleTimer()}async loadInitialState(){try{const t=await this.chrome.storage.session.get(V);if(Object.prototype.hasOwnProperty.call(t,V)){const s=t[V];if(s)try{K(s),this.state=w(ht(s)),this.logger.info("restored aggregated state",{tabs:Object.keys(this.state.tabs).length,lastTotal:this.state.lastTotal}),this.notifyListeners({reason:"init",previous:w(R),current:w(this.state)});return}catch(a){this.logger.warn("stored state invalid, resetting",a)}else this.logger.warn("stored state empty, resetting")}}catch(t){this.logger.error("failed to read storage",t)}this.state=w(R),await this.persistState(this.state),this.notifyListeners({reason:"init",previous:w(R),current:w(this.state)})}async updateState(t,s,a={}){const n=w(this.state),i=w(this.state);s(i,n)&&(X(i.debounce),K(i),await this.persistState(i),this.state=i,this.notifyListeners({reason:t,previous:n,current:w(this.state),...a}),this.refreshIdleTimer())}async persistState(t){const s={[V]:t};let a=0;for(;a<j;)try{await this.chrome.storage.session.set(s);return}catch(n){if(a+=1,this.logger.warn("failed to write state",{attempt:a,error:n}),a>=j)throw n;await Tt(lt)}}notifyListeners(t){for(const s of Array.from(this.listeners))try{s({...t,previous:w(t.previous),current:w(t.current),staleTabIds:t.staleTabIds?[...t.staleTabIds]:void 0})}catch(a){this.logger.error("listener threw",a)}}notifyIdleListeners(t){for(const s of Array.from(this.idleListeners))try{s(w(t))}catch(a){this.logger.error("idle listener threw",a)}}applyDebounceTransition(t,s){const a=this.now();if(t.lastTotal===0){if(s>0&&t.debounce.since===0)return t.debounce.since=a,!0}else if(t.debounce.since!==0)return t.debounce.since=0,!0;return!1}async applyDebounceDuration(t){const s=Math.min(Math.max(Math.trunc(t),0),6e4);let a=!1;await this.updateState("settings-updated",n=>n.debounce.ms===s?!1:(n.debounce.ms=s,a=!0,!0)),a||this.refreshIdleTimer()}refreshIdleTimer(){if(this.state.debounce.since===0){this.clearIdleTimer();return}if(this.state.lastTotal>0||!E(this.state.tabs)){this.clearIdleTimer();return}const t=this.state.debounce.since+this.state.debounce.ms,s=this.now();if(s>=t){this.clearIdleTimer(),this.handleIdleSettled();return}if(this.idleTimer&&this.idleTarget===t)return;this.clearIdleTimer();const a=Math.max(0,t-s);this.idleTarget=t,this.idleTimer=setTimeout(()=>{this.idleTimer=void 0,this.idleTarget=0,this.handleIdleSettled()},a),this.logger.debug("idle timer scheduled",{delay:a,target:t})}clearIdleTimer(){this.idleTimer&&(clearTimeout(this.idleTimer),this.idleTimer=void 0),this.idleTarget=0}async handleIdleSettled(){let t,s=!1;await this.updateState("debounce-cleared",a=>a.debounce.since===0||a.lastTotal!==0||!E(a.tabs)?!1:(a.debounce.since=0,s=!0,t=w(a),!0)),s&&t&&(this.logger.info("debounce window cleared"),this.notifyIdleListeners(t)),this.refreshIdleTimer()}resolveTitle(t,s){var i;const n=(((i=t.tab)==null?void 0:i.title)??"").trim();return n.length>0?n:s}createTabState(t,s,a){const n=Math.max(0,a);return{origin:t,title:s,count:0,active:!1,updatedAt:n,lastSeenAt:n,heartbeat:{lastReceivedAt:n,expectedIntervalMs:Z,status:"OK",missedCount:0}}}}const R={tabs:{},lastTotal:0,debounce:{ms:_,since:0}};function X(e){(typeof e.ms!="number"||Number.isNaN(e.ms))&&(e.ms=_),e.ms=Math.min(Math.max(e.ms,0),6e4),(typeof e.since!="number"||Number.isNaN(e.since)||e.since<0)&&(e.since=0)}function ht(e){var a,n;const t={};for(const[i,r]of Object.entries(e.tabs??{}))t[i]=ft(r);const s={tabs:t,lastTotal:k(t),debounce:{ms:((a=e.debounce)==null?void 0:a.ms)??_,since:((n=e.debounce)==null?void 0:n.since)??0}};return X(s.debounce),s}function ft(e){return{origin:e.origin,title:e.title,count:Math.max(0,e.count??0),active:!!e.active,updatedAt:e.updatedAt,lastSeenAt:e.lastSeenAt,heartbeat:gt(e.heartbeat),...e.signals?{signals:e.signals.map(t=>({...t}))}:{}}}function gt(e){return{lastReceivedAt:e.lastReceivedAt,expectedIntervalMs:q(e.expectedIntervalMs),status:e.status==="STALE"?"STALE":"OK",missedCount:Math.max(0,e.missedCount??0)}}function w(e){const t={};for(const[s,a]of Object.entries(e.tabs))t[s]={origin:a.origin,title:a.title,count:a.count,active:a.active,updatedAt:a.updatedAt,lastSeenAt:a.lastSeenAt,heartbeat:{...a.heartbeat},...a.signals?{signals:a.signals.map(n=>({...n}))}:{}};return{tabs:t,lastTotal:e.lastTotal,debounce:{...e.debounce}}}function k(e){const t=new Map;let s=0,a=!1,n=0;for(const i of Object.values(e)){const r=x(i.origin);if(r!=null&&r.isTasksListing){const c=r.canonical,u=t.get(c)??0,g=i.count>u?i.count:u;t.set(c,g);continue}if(r!=null&&r.isTaskDetails){a=!0,s=Math.max(s,i.count);continue}n+=i.count}if(a)return s;if(t.size>0){let i=0;for(const r of t.values())i+=r;return i}return n}function E(e){return Object.values(e).every(t=>t.count===0)}function bt(e,t){return!e&&!t?!0:!e||!t||e.length!==t.length?!1:e.every((s,a)=>{const n=t[a];return s.detector===n.detector&&s.evidence===n.evidence&&s.taskKey===n.taskKey})}function q(e){return Number.isFinite(e)?Math.min(Math.max(Math.trunc(e),1e3),6e4):Z}function Tt(e){return new Promise(t=>{setTimeout(t,e)})}function P(e){var a,n,i;return(((n=(a=(e??I()).i18n)==null?void 0:a.getUILanguage)==null?void 0:n.call(a))??((i=globalThis.navigator)==null?void 0:i.language)??"en").toLowerCase().startsWith("ru")?"ru":"en"}const mt=[0,0,0,0],pt=200,F=9,H=[16,24,32],yt=.92,B=[{threshold:0,color:"#16A34A"},{threshold:1,color:"#F97316"},{threshold:2,color:"#F2542D"},{threshold:3,color:"#E11D48"},{threshold:4,color:"#C2185B"}],St="#7C3AED",z={en:e=>`${e} active Codex tasks`,ru:e=>`${e} активных задач Codex`};function wt(e,t={}){const s=t.chrome??I(),a=s.action,n=t.logger??D("codex-background"),i=O(n,"action-indicator");if(!a)return i.warn("chrome.action API is unavailable; badge indicator disabled"),{dispose(){}};let r=!1;const c=P(s),u=z[c]??z.en,g=J(),y=a.setBadgeBackgroundColor.bind(a),T=a.setBadgeText.bind(a),d=a.setTitle?a.setTitle.bind(a):void 0,l=a.setIcon?a.setIcon.bind(a):void 0,f=a.setBadgeTextColor?a.setBadgeTextColor.bind(a):void 0;g||i.debug("OffscreenCanvas/ImageData unavailable; falling back to badge text");const o=et(async b=>{if(r)return;const p=At(b.lastTotal??0,{hasCodexTabs:Object.keys(b.tabs).length>0});if(await m(()=>y({color:mt})),await m(()=>T({text:""})),d&&await m(()=>d({title:u(p.text)})),g&&l){const S=It(p.text,p.color,i);S&&await m(()=>l({imageData:S}))}else f&&(await m(()=>f({color:p.color})),await m(()=>T({text:p.text})))},pt),h=e.onStateChange(b=>{o(b.current)});return e.ready.then(()=>e.getSnapshot()).then(b=>o(b)).catch(b=>{i.error("failed to apply initial badge state",b)}),{dispose(){var b;r=!0,h(),(b=o.cancel)==null||b.call(o)}};async function m(b){try{await b()}catch(p){i.warn("action API call failed",p)}}}function At(e,t={}){const s=Number.isFinite(e)?Math.max(0,Math.trunc(e)):0;if(!(t.hasCodexTabs??!0)&&s===0)return{text:"0",color:St};const n=s>F?String(F):String(s),i=vt(s);return{text:n,color:i}}function vt(e){for(let t=B.length-1;t>=0;t-=1){const s=B[t];if(e>=s.threshold)return s.color}return B[0].color}function J(){return typeof OffscreenCanvas<"u"&&typeof ImageData<"u"}function It(e,t,s){if(J())try{const a={};for(const n of H)a[n]=Ct(n,e,t);return a}catch(a){return s.warn("failed to render text icon, falling back to transparent icon",a),Dt(H)}}function Ct(e,t,s){const n=new OffscreenCanvas(e,e).getContext("2d");if(!n)throw new Error("OffscreenCanvas context unavailable");n.clearRect(0,0,e,e),n.fillStyle=s,n.textAlign="center",n.textBaseline="middle";const i=Math.floor(e*yt);n.font=`900 ${i}px "Inter","Segoe UI","Roboto",sans-serif`,n.lineJoin="round";const r=Math.max(1,Math.floor(e*.08));return n.strokeStyle="rgba(0,0,0,0.08)",n.lineWidth=r,n.strokeText(t,e/2,e/2),n.fillText(t,e/2,e/2),n.getImageData(0,0,e,e)}function Dt(e){const t={};for(const s of e)t[s]=Ot(s);return t}function Ot(e){const t=e*e*4,s=new Uint8ClampedArray(t);return new ImageData(s,e,e)}function Mt(e,t={}){const s=t.chrome??I(),a=O(t.logger??D("codex-background"),"audio-trigger"),n=new Lt(e,s,a);return{dispose(){n.dispose()}}}class Lt{constructor(t,s,a){this.aggregator=t,this.chrome=s,this.logger=a,this.disposed=!1,this.soundEnabled=C.sound,this.soundVolume=C.soundVolume,this.settingsInitialized=!1,this.idleUnsubscribe=t.onIdleSettled(n=>{this.handleIdleSettled(n)}),this.storageListener=(n,i)=>{if(this.disposed||i!=="sync")return;const r={},c=n.sound;c&&typeof c.newValue=="boolean"&&(r.sound=c.newValue);const u=n.soundVolume;u&&typeof u.newValue=="number"&&(r.soundVolume=u.newValue),Object.keys(r).length>0&&this.applySettings(r)},this.chrome.storage.onChanged.addListener(this.storageListener),t.ready.catch(n=>{this.logger.warn("failed to init audio trigger state",n)}),this.refreshSettings()}dispose(){this.disposed||(this.disposed=!0,this.idleUnsubscribe(),this.chrome.storage.onChanged.removeListener(this.storageListener))}async refreshSettings(){try{const t=await W(this.chrome);this.applySettings({sound:t.sound,soundVolume:t.soundVolume})}catch(t){this.logger.debug("failed to load audio settings",t)}}applySettings(t){let s=!this.settingsInitialized;if(typeof t.sound=="boolean"&&t.sound!==this.soundEnabled&&(this.soundEnabled=t.sound,s=!0),typeof t.soundVolume=="number"){const a=G(t.soundVolume);a!==this.soundVolume&&(this.soundVolume=a,s=!0)}this.settingsInitialized=!0,s&&this.broadcastSettingsUpdate()}async broadcastSettingsUpdate(){const t={type:"AUDIO_SETTINGS_UPDATE",sound:this.soundEnabled,soundVolume:this.soundVolume};await this.sendRuntimeMessage(t),await this.sendTabMessages(t)}async broadcastAudioChime(){if(!this.soundEnabled)return;const t=G(this.soundVolume);if(t<=0)return;const s={type:"AUDIO_CHIME",volume:t};await this.sendRuntimeMessage(s),await this.sendTabMessages(s)}async handleIdleSettled(t){this.disposed||t.lastTotal!==0||!Et(t)||await this.broadcastAudioChime()}async sendRuntimeMessage(t){try{await this.chrome.runtime.sendMessage(t)}catch(s){this.logger.debug("runtime audio message failed",s)}}async sendTabMessages(t){try{const s=await this.aggregator.getTrackedTabIds();await Promise.all(s.map(async a=>{try{await this.chrome.tabs.sendMessage(a,t)}catch(n){this.logger.debug("audio tab message failed",{tabId:a,error:n})}}))}catch(s){this.logger.debug("audio tab broadcast failed",s)}}}function G(e){return Number.isFinite(e)?e<=0?0:e>=1?1:e:C.soundVolume}function Et(e){return Object.values(e.tabs).every(t=>t.count===0)}async function kt(e,t={}){var T;const s=await e.getSnapshot(),a=t.chrome??I(),n=t.locale??P(a),i=((T=t.now)==null?void 0:T.call(t))??Date.now(),r=new Date(i).toISOString(),c=Vt(s).filter(d=>d.count>0);c.sort((d,l)=>{if(l.count!==d.count)return l.count-d.count;const f=d.lastSeenAt??0,o=l.lastSeenAt??0;return o!==f?o-f:l.tabId-d.tabId});const u=_t(s.lastTotal),g={...it(n)},y={generatedAt:r,totalActive:u,tabs:c,locale:n,messages:g};return at(y),y}function _t(e){return Number.isFinite(e)?Math.max(0,Math.trunc(e)):0}function Vt(e){const t=[];for(const[s,a]of Object.entries(e.tabs)){const n=Number(s);if(!Number.isFinite(n))continue;const i=a.signals?a.signals.map(r=>({...r})):[];t.push({tabId:n,title:a.title,origin:a.origin,count:Math.max(0,a.count),lastSeenAt:a.lastSeenAt,heartbeatStatus:a.heartbeat.status,signals:i})}return t}const N="codex-poll",Y=1;function Rt(e,t={}){const s=t.chrome??I(),a=t.logger??D("codex-background"),n=O(a,"alarms"),i=t.settings;s.alarms.create(N,{periodInMinutes:Y}),n.info("alarm scheduled",{name:N,periodMinutes:Y});const r=new Set;let c=(i==null?void 0:i.getSnapshot().autoDiscardableOff)??C.autoDiscardableOff;const u=i?i.onChange(o=>{c=o.autoDiscardableOff,l()}):void 0,g=e.onStateChange(o=>{T(o.current).catch(h=>{n.warn("failed to enforce autoDiscardable",h)}),(o.reason==="tab-removed"||o.reason==="tab-navigated")&&typeof o.tabId=="number"&&d(o.tabId)});e.ready.then(()=>l()).catch(o=>{n.error("failed to apply autoDiscardable on startup",o)}),i?i.ready.then(()=>(c=i.getSnapshot().autoDiscardableOff,l())).catch(o=>{n.warn("failed to sync autoDiscardable settings",o)}):l().catch(o=>{n.warn("failed to apply autoDiscardable on initial snapshot",o)});const y=o=>{o.name===N&&f().catch(h=>{n.error("alarm tick failed",h)})};return s.alarms.onAlarm.addListener(y),{dispose(){s.alarms.onAlarm.removeListener(y),g(),r.clear(),u==null||u()}};async function T(o){if(c){for(const h of Object.keys(o.tabs).map(Number))if(!r.has(h))try{await s.tabs.update(h,{autoDiscardable:!1}),r.add(h),n.debug("autoDiscardable disabled",{tabId:h})}catch(m){n.warn("autoDiscardable update failed",{tabId:h,error:m})}for(const h of Array.from(r))o.tabs[String(h)]||r.delete(h);return}for(const h of Array.from(r)){try{await s.tabs.update(h,{autoDiscardable:!0}),n.debug("autoDiscardable restored",{tabId:h})}catch(m){n.warn("autoDiscardable restore failed",{tabId:h,error:m})}r.delete(h)}}async function d(o){if(r.has(o)){r.delete(o);try{await s.tabs.update(o,{autoDiscardable:!0}),n.debug("autoDiscardable restored",{tabId:o})}catch(h){n.warn("autoDiscardable restore failed",{tabId:o,error:h})}}}async function l(){const o=await e.getSnapshot();await T(o)}async function f(){n.debug("alarm tick");const o=await e.evaluateHeartbeatStatuses();if(o.length!==0)for(const h of o)try{await s.tabs.sendMessage(h,{type:"PING"}),n.info("ping sent to tab",{tabId:h})}catch(m){n.warn("failed to ping tab",{tabId:h,error:m})}}}const $="codex-tasks-zero",xt={en:{title:"Codex",message:"All Codex tasks are complete",buttonOk:"OK"},ru:{title:"Codex",message:"Все задачи Codex завершены",buttonOk:"ОК"}};function Bt(e,t={}){const s=t.chrome??I(),a=t.logger??D("codex-background"),n=O(a,"notifications"),i=P(s),r=xt[i];let c=!1,u;const g=e.onStateChange(l=>{c||l.current.lastTotal>0&&d()}),y=e.onIdleSettled(l=>{c||T(l).catch(f=>{n.error("idle notification failed",f)})});return e.ready.then(()=>e.getSnapshot()).then(l=>{if(l.lastTotal>0)return d()}).catch(l=>{n.error("failed to read initial state",l)}),{dispose(){c=!0,g(),y(),d()}};async function T(l){if(!c){if(l.lastTotal!==0||!Nt(l)){n.debug("notification skipped due to activity");return}await d();try{u=await s.notifications.create($,{type:"basic",title:r.title,message:r.message,iconUrl:"assets/icon128.png",buttons:[{title:r.buttonOk}]})??$,n.info("notification created",{notificationId:u})}catch(f){n.error("failed to create notification",f)}}}async function d(){if(u){try{await s.notifications.clear(u),n.debug("notification cleared",{notificationId:u})}catch(l){n.warn("failed to clear notification",l)}u=void 0}}}function Nt(e){return Object.values(e.tabs).every(t=>t.count===0)}function Ut(e={}){return new Pt(e)}class Pt{constructor(t){this.settings={...C},this.listeners=new Set,this.chrome=t.chrome??I();const s=t.logger??D("codex-background");this.logger=O(s,"settings"),this.ready=this.refreshSettings(),this.chrome.storage.onChanged.addListener((a,n)=>{if(n!=="sync")return;const i={},r=a.debounceMs;r&&typeof r.newValue=="number"&&(i.debounceMs=r.newValue);const c=a.sound;c&&typeof c.newValue=="boolean"&&(i.sound=c.newValue);const u=a.soundVolume;u&&typeof u.newValue=="number"&&(i.soundVolume=u.newValue);const g=a.autoDiscardableOff;g&&typeof g.newValue=="boolean"&&(i.autoDiscardableOff=g.newValue);const y=a.showBadgeCount;y&&typeof y.newValue=="boolean"&&(i.showBadgeCount=y.newValue),Object.keys(i).length!==0&&this.applyPatch(i)})}getSnapshot(){return{...this.settings}}onChange(t){return this.listeners.add(t),()=>{this.listeners.delete(t)}}async refreshSettings(){try{const t=await W(this.chrome);this.applySettings(t)}catch(t){this.logger.warn("failed to load user settings",t),this.applySettings({...C})}}applyPatch(t){const s=rt({...this.settings,...t});Kt(this.settings,s)||this.applySettings(s)}applySettings(t){this.settings={...t},this.notifyListeners()}notifyListeners(){const t=this.getSnapshot();for(const s of Array.from(this.listeners))try{s({...t})}catch(a){this.logger.error("settings listener threw",a)}}}function Kt(e,t){return e.debounceMs===t.debounceMs&&e.sound===t.sound&&e.soundVolume===t.soundVolume&&e.autoDiscardableOff===t.autoDiscardableOff&&e.showBadgeCount===t.showBadgeCount}const U="codex.tasks.verbose",v=I(),{logger:A}=Ft(v),Q=Ut({chrome:v,logger:A}),M=dt({chrome:v,logger:A,settings:Q});Bt(M,{chrome:v,logger:A});wt(M,{chrome:v,logger:A});Mt(M,{chrome:v,logger:A});Rt(M,{chrome:v,logger:A,settings:Q});v.runtime.onMessage.addListener((e,t,s)=>(jt(M,O(A,"runtime"),e,t).then(a=>{try{s(a)}catch(n){A.warn("sendResponse failed",n)}}).catch(a=>{A.error("message handling failed",a);try{s(void 0)}catch(n){A.warn("sendResponse failed",n)}}),!0));v.tabs.onRemoved.addListener(e=>{M.handleTabRemoved(e).catch(t=>{A.error("tab removal handling failed",{tabId:e,error:t})})});v.tabs.onUpdated.addListener((e,t)=>{if(!t.url)return;const s=x(t.url);s!=null&&s.isTasksListing||s!=null&&s.isTaskDetails||M.handleTabNavigated(e).catch(a=>{A.error("tab navigation handling failed",{tabId:e,error:a})})});async function jt(e,t,s,a){if(!s||typeof s!="object")return;const{type:n}=s;if(n==="TASKS_UPDATE"){try{st(s)}catch(i){t.warn("invalid TASKS_UPDATE payload",i);return}await e.handleTasksUpdate(s,a);return}if(n==="TASKS_HEARTBEAT"){try{nt(s)}catch(i){t.warn("invalid TASKS_HEARTBEAT payload",i);return}await e.handleHeartbeat(s,a);return}if(n==="POPUP_GET_STATE"){const i=await kt(e);return t.debug("popup state generated",{totalActive:i.totalActive}),i}t.debug("unknown message type ignored",{type:n})}function Ft(e){let t=!1;const a=D("codex-background",{debug:(...i)=>{t&&console.debug(...i)},info:(...i)=>console.info(...i),warn:(...i)=>console.warn(...i),error:(...i)=>console.error(...i)});n(),e.storage.onChanged.addListener((i,r)=>{if(r!=="session")return;const c=i[U];if(!c)return;const u=!!c.newValue;u!==t&&(t=u,a.info("verbose flag toggled",{verbose:t}))});async function n(){try{const r=!!(await e.storage.session.get({[U]:!1}))[U];r!==t&&(t=r,a.info("verbose flag toggled",{verbose:t}))}catch(i){console.warn("failed to read verbose flag",i)}}return{logger:a}}
