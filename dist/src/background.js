import{r as A,c as v,a as I,b as B,t as $,d as q,e as J,f as Q}from"../assets/chrome-CWUhAqIv.js";import{c as tt}from"../assets/url-odDJkPYl.js";import{S as R,l as et,g as at}from"../assets/messages-OUg0OvmT.js";function nt(){return"codex.tasks.state"}const U=12e3,z=15e3,st=3,L=nt(),K=3,ot=1e3;function rt(e={}){return new it(e)}class it{constructor(t){this.state=T(x),this.listeners=new Set,this.chrome=t.chrome??A();const a=t.logger??v("codex-background");this.logger=I(a,"aggregator"),this.now=t.now??(()=>Date.now()),this.ready=this.loadInitialState()}onStateChange(t){return this.listeners.add(t),()=>{this.listeners.delete(t)}}async getSnapshot(){return await this.ready,T(this.state)}async getTrackedTabIds(){return await this.ready,Object.keys(this.state.tabs).map(t=>Number(t))}async handleTasksUpdate(t,a){var s;await this.ready;const n=(s=a.tab)==null?void 0:s.id;if(typeof n!="number"){this.logger.warn("TASKS_UPDATE without tab id",{message:t});return}await this.updateState("tasks-update",(o,i)=>{const l=String(n),h=this.resolveTitle(a,t.origin),f=Object.prototype.hasOwnProperty.call((i==null?void 0:i.tabs)??{},l),r=o.tabs[l]??this.createTabState(t.origin,h,t.ts);let c=!f;r.origin!==t.origin&&(r.origin=t.origin,c=!0),r.title!==h&&(r.title=h,c=!0),r.count!==t.count&&(r.count=t.count,c=!0),r.active!==t.active&&(r.active=t.active,c=!0),r.updatedAt!==t.ts&&(r.updatedAt=t.ts,c=!0);const u=r.heartbeat,d=Math.max(u.lastReceivedAt,t.ts);u.lastReceivedAt!==d&&(u.lastReceivedAt=d,c=!0),u.status!=="OK"&&(u.status="OK",c=!0),u.missedCount!==0&&(u.missedCount=0,c=!0);const g=Math.max(d,r.lastSeenAt,t.ts);r.lastSeenAt!==g&&(r.lastSeenAt=g,c=!0);const m=t.signals.map(b=>({...b}));ht(r.signals,m)||(r.signals=m,c=!0),o.tabs[l]=r;const y=N(o.tabs);o.lastTotal!==y&&(o.lastTotal=y,c=!0);const M=(i==null?void 0:i.lastTotal)??0;return c=this.applyDebounceTransition(o,M)||c,c},{tabId:n}),this.logger.debug("TASKS_UPDATE processed",{tabId:n,count:t.count,active:t.active})}async handleHeartbeat(t,a){var s;await this.ready;const n=(s=a.tab)==null?void 0:s.id;if(typeof n!="number"){this.logger.warn("TASKS_HEARTBEAT without tab id",{message:t});return}await this.updateState("heartbeat",(o,i)=>{const l=String(n),h=this.resolveTitle(a,t.origin),f=Math.max(0,t.ts),r=Math.max(f,t.lastUpdateTs),c=Object.prototype.hasOwnProperty.call((i==null?void 0:i.tabs)??{},l),u=o.tabs[l]??this.createTabState(t.origin,h,r);let d=!c;u.origin!==t.origin&&(u.origin=t.origin,d=!0),u.title!==h&&(u.title=h,d=!0),u.updatedAt<r&&(u.updatedAt=r,d=!0);const g=u.heartbeat,m=X(t.intervalMs);g.expectedIntervalMs!==m&&(g.expectedIntervalMs=m,d=!0),g.lastReceivedAt!==f&&(g.lastReceivedAt=f,d=!0),g.status!=="OK"&&(g.status="OK",d=!0),g.missedCount!==0&&(g.missedCount=0,d=!0);const y=Math.max(u.lastSeenAt,f,u.updatedAt);return u.lastSeenAt!==y&&(u.lastSeenAt=y,d=!0),o.tabs[l]=u,d},{tabId:n}),this.logger.debug("TASKS_HEARTBEAT processed",{tabId:n,intervalMs:t.intervalMs})}async handleTabRemoved(t){await this.ready,await this.updateState("tab-removed",a=>{const n=String(t);if(!(n in a.tabs))return!1;delete a.tabs[n];const s=N(a.tabs);return a.lastTotal!==s&&(a.lastTotal=s),s===0&&a.debounce.since!==0&&(a.debounce.since=0),!0},{tabId:t}),this.logger.info("tab removed",{tabId:t})}async evaluateHeartbeatStatuses(){await this.ready;const t=[];return await this.updateState("heartbeat-stale",a=>{let n=!1;const s=this.now();for(const[o,i]of Object.entries(a.tabs)){const{heartbeat:l}=i,h=l.expectedIntervalMs*st;s-l.lastReceivedAt>=h&&(t.push(Number(o)),l.status="STALE",l.missedCount+=1,n=!0)}return n},{staleTabIds:[...t]}),t.length>0&&this.logger.warn("heartbeat stale detected",{tabIds:t}),t}async clearDebounceIfIdle(){await this.ready;let t=!1;return await this.updateState("debounce-cleared",a=>a.debounce.since===0?!1:a.lastTotal===0&&dt(a.tabs)?(a.debounce.since=0,t=!0,!0):!1),t&&this.logger.info("debounce window cleared"),t}async loadInitialState(){try{const a=(await this.chrome.storage.session.get({[L]:x}))[L];if(a)try{B(a),this.state=T(ct(a)),this.logger.info("restored aggregated state",{tabs:Object.keys(this.state.tabs).length,lastTotal:this.state.lastTotal}),this.notifyListeners({reason:"init",previous:T(x),current:T(this.state)});return}catch(n){this.logger.warn("stored state invalid, resetting",n)}}catch(t){this.logger.error("failed to read storage",t)}this.state=T(x),await this.persistState(this.state),this.notifyListeners({reason:"init",previous:T(x),current:T(this.state)})}async updateState(t,a,n={}){const s=T(this.state),o=T(this.state);a(o,s)&&(W(o.debounce),B(o),await this.persistState(o),this.state=o,this.notifyListeners({reason:t,previous:s,current:T(this.state),...n}))}async persistState(t){const a={[L]:t};let n=0;for(;n<K;)try{await this.chrome.storage.session.set(a);return}catch(s){if(n+=1,this.logger.warn("failed to write state",{attempt:n,error:s}),n>=K)throw s;await ft(ot)}}notifyListeners(t){for(const a of Array.from(this.listeners))try{a({...t,previous:T(t.previous),current:T(t.current),staleTabIds:t.staleTabIds?[...t.staleTabIds]:void 0})}catch(n){this.logger.error("listener threw",n)}}applyDebounceTransition(t,a){const n=this.now();if(t.lastTotal===0){if(a>0&&t.debounce.since===0)return t.debounce.since=n,!0}else if(t.debounce.since!==0)return t.debounce.since=0,!0;return!1}resolveTitle(t,a){var o;const s=(((o=t.tab)==null?void 0:o.title)??"").trim();return s.length>0?s:a}createTabState(t,a,n){const s=Math.max(0,n);return{origin:t,title:a,count:0,active:!1,updatedAt:s,lastSeenAt:s,heartbeat:{lastReceivedAt:s,expectedIntervalMs:z,status:"OK",missedCount:0}}}}const x={tabs:{},lastTotal:0,debounce:{ms:U,since:0}};function W(e){(typeof e.ms!="number"||Number.isNaN(e.ms))&&(e.ms=U),e.ms=Math.min(Math.max(e.ms,0),6e4),(typeof e.since!="number"||Number.isNaN(e.since)||e.since<0)&&(e.since=0)}function ct(e){var n,s;const t={};for(const[o,i]of Object.entries(e.tabs??{}))t[o]=lt(i);const a={tabs:t,lastTotal:N(t),debounce:{ms:((n=e.debounce)==null?void 0:n.ms)??U,since:((s=e.debounce)==null?void 0:s.since)??0}};return W(a.debounce),a}function lt(e){return{origin:e.origin,title:e.title,count:Math.max(0,e.count??0),active:!!e.active,updatedAt:e.updatedAt,lastSeenAt:e.lastSeenAt,heartbeat:ut(e.heartbeat),...e.signals?{signals:e.signals.map(t=>({...t}))}:{}}}function ut(e){return{lastReceivedAt:e.lastReceivedAt,expectedIntervalMs:X(e.expectedIntervalMs),status:e.status==="STALE"?"STALE":"OK",missedCount:Math.max(0,e.missedCount??0)}}function T(e){const t={};for(const[a,n]of Object.entries(e.tabs))t[a]={origin:n.origin,title:n.title,count:n.count,active:n.active,updatedAt:n.updatedAt,lastSeenAt:n.lastSeenAt,heartbeat:{...n.heartbeat},...n.signals?{signals:n.signals.map(s=>({...s}))}:{}};return{tabs:t,lastTotal:e.lastTotal,debounce:{...e.debounce}}}function N(e){const t=new Map;let a=!1,n=0,s=!1,o=0;for(const i of Object.values(e)){const l=tt(i.origin);if(l!=null&&l.isTasksListing){a=!0;const h=l.canonical,f=t.get(h)??0,r=i.count>f?i.count:f;t.set(h,r);continue}if(l!=null&&l.isTaskDetails){s=!0,n=Math.max(n,i.count);continue}o+=i.count}if(!a&&s)return n;if(t.size>0){let i=0;for(const l of t.values())i+=l;return i}return s?n:o}function dt(e){return Object.values(e).every(t=>t.count===0)}function ht(e,t){return!e&&!t?!0:!e||!t||e.length!==t.length?!1:e.every((a,n)=>{const s=t[n];return a.detector===s.detector&&a.evidence===s.evidence&&a.taskKey===s.taskKey})}function X(e){return Number.isFinite(e)?Math.min(Math.max(Math.trunc(e),1e3),6e4):z}function ft(e){return new Promise(t=>{setTimeout(t,e)})}function V(e){var n,s,o;return(((s=(n=(e??A()).i18n)==null?void 0:n.getUILanguage)==null?void 0:s.call(n))??((o=globalThis.navigator)==null?void 0:o.language)??"en").toLowerCase().startsWith("ru")?"ru":"en"}const gt=[0,0,0,0],bt=200,P=9,j=[16,24,32],mt=.92,D=[{threshold:0,color:"#16A34A"},{threshold:1,color:"#F97316"},{threshold:2,color:"#F2542D"},{threshold:3,color:"#E11D48"},{threshold:4,color:"#C2185B"}],Tt="#7C3AED",H={en:e=>`${e} active Codex tasks`,ru:e=>`${e} активных задач Codex`};function pt(e,t={}){const a=t.chrome??A(),n=a.action,s=t.logger??v("codex-background"),o=I(s,"action-indicator");if(!n)return o.warn("chrome.action API is unavailable; badge indicator disabled"),{dispose(){}};let i=!1;const l=V(a),h=H[l]??H.en,f=Z();f||o.debug("OffscreenCanvas/ImageData unavailable; falling back to badge text");const r=$(async d=>{if(i)return;const g=St(d.lastTotal??0,{hasCodexTabs:Object.keys(d.tabs).length>0});if(await u(()=>n.setBadgeBackgroundColor({color:gt})),await u(()=>n.setBadgeText({text:""})),n.setTitle&&await u(()=>n.setTitle({title:h(g.text)})),f&&n.setIcon){const m=At(g.text,g.color,o);m&&await u(()=>n.setIcon({imageData:m}))}else n.setBadgeTextColor&&(await u(()=>n.setBadgeTextColor({color:g.color})),await u(()=>n.setBadgeText({text:g.text})))},bt),c=e.onStateChange(d=>{r(d.current)});return e.ready.then(()=>e.getSnapshot()).then(d=>r(d)).catch(d=>{o.error("failed to apply initial badge state",d)}),{dispose(){var d;i=!0,c(),(d=r.cancel)==null||d.call(r)}};async function u(d){try{await d()}catch(g){o.warn("action API call failed",g)}}}function St(e,t={}){const a=Number.isFinite(e)?Math.max(0,Math.trunc(e)):0;if(!(t.hasCodexTabs??!0)&&a===0)return{text:"0",color:Tt};const s=a>P?String(P):String(a),o=yt(a);return{text:s,color:o}}function yt(e){for(let t=D.length-1;t>=0;t-=1){const a=D[t];if(e>=a.threshold)return a.color}return D[0].color}function Z(){return typeof OffscreenCanvas<"u"&&typeof ImageData<"u"}function At(e,t,a){if(Z())try{const n={};for(const s of j)n[s]=wt(s,e,t);return n}catch(n){return a.warn("failed to render text icon, falling back to transparent icon",n),vt(j)}}function wt(e,t,a){const s=new OffscreenCanvas(e,e).getContext("2d");if(!s)throw new Error("OffscreenCanvas context unavailable");s.clearRect(0,0,e,e),s.fillStyle=a,s.textAlign="center",s.textBaseline="middle";const o=Math.floor(e*mt);s.font=`900 ${o}px "Inter","Segoe UI","Roboto",sans-serif`,s.lineJoin="round";const i=Math.max(1,Math.floor(e*.08));return s.strokeStyle="rgba(0,0,0,0.08)",s.lineWidth=i,s.strokeText(t,e/2,e/2),s.fillText(t,e/2,e/2),s.getImageData(0,0,e,e)}function vt(e){const t={};for(const a of e)t[a]=It(a);return t}function It(e){const t=e*e*4,a=new Uint8ClampedArray(t);return new ImageData(a,e,e)}function Et(e,t={}){const a=t.chrome??A(),n=I(t.logger??v("codex-background"),"audio-trigger"),s=new Ct(e,a,n);return{dispose(){s.dispose()}}}class Ct{constructor(t,a,n){this.aggregator=t,this.chrome=a,this.logger=n,this.disposed=!1,this.soundEnabled=R.sound,this.soundVolume=R.soundVolume,this.settingsInitialized=!1,this.unsubscribe=t.onStateChange(s=>{this.handleStateChange(s)}),this.storageListener=(s,o)=>{if(this.disposed||o!=="sync")return;const i={},l=s.sound;l&&typeof l.newValue=="boolean"&&(i.sound=l.newValue);const h=s.soundVolume;h&&typeof h.newValue=="number"&&(i.soundVolume=h.newValue),Object.keys(i).length>0&&this.applySettings(i)},this.chrome.storage.onChanged.addListener(this.storageListener),t.ready.catch(s=>{this.logger.warn("failed to init audio trigger state",s)}),this.refreshSettings()}dispose(){this.disposed||(this.disposed=!0,this.unsubscribe(),this.chrome.storage.onChanged.removeListener(this.storageListener))}async refreshSettings(){try{const t=await et(this.chrome);this.applySettings({sound:t.sound,soundVolume:t.soundVolume})}catch(t){this.logger.debug("failed to load audio settings",t)}}applySettings(t){let a=!this.settingsInitialized;if(typeof t.sound=="boolean"&&t.sound!==this.soundEnabled&&(this.soundEnabled=t.sound,a=!0),typeof t.soundVolume=="number"){const n=F(t.soundVolume);n!==this.soundVolume&&(this.soundVolume=n,a=!0)}this.settingsInitialized=!0,a&&this.broadcastSettingsUpdate()}async handleStateChange(t){if(this.disposed)return;const a=t.previous.lastTotal??0,n=t.current.lastTotal??0;a>0&&n===0&&await this.broadcastAudioChime()}async broadcastSettingsUpdate(){const t={type:"AUDIO_SETTINGS_UPDATE",sound:this.soundEnabled,soundVolume:this.soundVolume};await this.sendRuntimeMessage(t),await this.sendTabMessages(t)}async broadcastAudioChime(){if(!this.soundEnabled)return;const t=F(this.soundVolume);if(t<=0)return;const a={type:"AUDIO_CHIME",volume:t};await this.sendRuntimeMessage(a),await this.sendTabMessages(a)}async sendRuntimeMessage(t){try{await this.chrome.runtime.sendMessage(t)}catch(a){this.logger.debug("runtime audio message failed",a)}}async sendTabMessages(t){try{const a=await this.aggregator.getTrackedTabIds();await Promise.all(a.map(async n=>{try{await this.chrome.tabs.sendMessage(n,t)}catch(s){this.logger.debug("audio tab message failed",{tabId:n,error:s})}}))}catch(a){this.logger.debug("audio tab broadcast failed",a)}}}function F(e){return Number.isFinite(e)?e<=0?0:e>=1?1:e:R.soundVolume}async function xt(e,t={}){var c;const a=await e.getSnapshot(),n=t.chrome??A(),s=t.locale??V(n),o=((c=t.now)==null?void 0:c.call(t))??Date.now(),i=new Date(o).toISOString(),l=Mt(a).filter(u=>u.count>0);l.sort((u,d)=>{if(d.count!==u.count)return d.count-u.count;const g=u.lastSeenAt??0,m=d.lastSeenAt??0;return m!==g?m-g:d.tabId-u.tabId});const h=Math.max(0,l.reduce((u,d)=>u+d.count,0)),f={...at(s)},r={generatedAt:i,totalActive:h,tabs:l,locale:s,messages:f};return q(r),r}function Mt(e){const t=[];for(const[a,n]of Object.entries(e.tabs)){const s=Number(a);Number.isFinite(s)&&t.push({tabId:s,title:n.title,origin:n.origin,count:Math.max(0,n.count),lastSeenAt:n.lastSeenAt,heartbeatStatus:n.heartbeat.status,signals:n.signals?n.signals.map(o=>({...o})):[]})}return t}const k="codex-poll",G=1;function Ot(e,t={}){const a=t.chrome??A(),n=t.logger??v("codex-background"),s=I(n,"alarms");a.alarms.create(k,{periodInMinutes:G}),s.info("alarm scheduled",{name:k,periodMinutes:G});const o=new Set,i=e.onStateChange(r=>{h(r.current).catch(c=>{s.warn("failed to enforce autoDiscardable",c)}),r.reason==="tab-removed"&&typeof r.tabId=="number"&&o.delete(r.tabId)});e.ready.then(()=>e.getSnapshot()).then(r=>h(r)).catch(r=>{s.error("failed to apply autoDiscardable on startup",r)}),e.getSnapshot().then(r=>h(r)).catch(r=>{s.warn("failed to apply autoDiscardable on initial snapshot",r)});const l=r=>{r.name===k&&f().catch(c=>{s.error("alarm tick failed",c)})};return a.alarms.onAlarm.addListener(l),{dispose(){a.alarms.onAlarm.removeListener(l),i(),o.clear()}};async function h(r){for(const c of Object.keys(r.tabs).map(Number))if(!o.has(c))try{await a.tabs.update(c,{autoDiscardable:!1}),o.add(c),s.debug("autoDiscardable disabled",{tabId:c})}catch(u){s.warn("autoDiscardable update failed",{tabId:c,error:u})}for(const c of Array.from(o))r.tabs[String(c)]||o.delete(c)}async function f(){s.debug("alarm tick");const r=await e.evaluateHeartbeatStatuses();if(r.length!==0)for(const c of r)try{await a.tabs.sendMessage(c,{type:"PING"}),s.info("ping sent to tab",{tabId:c})}catch(u){s.warn("failed to ping tab",{tabId:c,error:u})}}}const Y="codex-tasks-zero",Lt={en:{title:"Codex",message:"All Codex tasks are complete",buttonOk:"OK"},ru:{title:"Codex",message:"Все задачи Codex завершены",buttonOk:"ОК"}};function Dt(e,t={}){const a=t.chrome??A(),n=t.logger??v("codex-background"),s=I(n,"notifications"),o=t.now??(()=>Date.now()),i=V(a),l=Lt[i];let h=!1,f,r=0,c;const u=e.onStateChange(b=>{h||d(b.current).catch(S=>{s.error("state change handling failed",S)})});return e.ready.then(()=>e.getSnapshot()).then(b=>d(b)).catch(b=>{s.error("failed to read initial state",b)}),{dispose(){h=!0,f&&(clearTimeout(f),f=void 0),r=0,u()}};async function d(b){if(!h){if(b.lastTotal>0){m(),await M();return}if(b.debounce.since===0){m();return}g(b)}}function g(b){const S=b.debounce.since+b.debounce.ms,O=o();if(O>=S){y();return}if(f&&r===S)return;m();const C=Math.max(0,S-O);r=S,f=setTimeout(()=>{f=void 0,r=0,y()},C),s.debug("debounce timer scheduled",{delay:C,target:S})}function m(){f&&(clearTimeout(f),f=void 0),r=0}async function y(){if(h)return;const b=await e.getSnapshot();if(b.debounce.since===0){s.debug("debounce window already cleared");return}const S=b.debounce.since+b.debounce.ms;if(o()<S){s.debug("debounce window not ready yet"),g(b);return}if(b.lastTotal!==0||!kt(b)){s.info("activity detected during debounce, skipping notification"),m();return}try{c=await a.notifications.create(Y,{type:"basic",title:l.title,message:l.message,iconUrl:"assets/icon128.png",buttons:[{title:l.buttonOk}]})??Y,s.info("notification created",{notificationId:c})}catch(C){s.error("failed to create notification",C)}finally{m(),await e.clearDebounceIfIdle()}}async function M(){if(c){try{await a.notifications.clear(c),s.debug("notification cleared",{notificationId:c})}catch(b){s.warn("failed to clear notification",b)}c=void 0}}}function kt(e){return Object.values(e.tabs).every(t=>t.count===0)}const _="codex.tasks.verbose",w=A(),{logger:p}=Rt(w),E=rt({chrome:w,logger:p});Dt(E,{chrome:w,logger:p});pt(E,{chrome:w,logger:p});Et(E,{chrome:w,logger:p});Ot(E,{chrome:w,logger:p});w.runtime.onMessage.addListener((e,t,a)=>(_t(E,I(p,"runtime"),e,t).then(n=>{try{a(n)}catch(s){p.warn("sendResponse failed",s)}}).catch(n=>{p.error("message handling failed",n);try{a(void 0)}catch(s){p.warn("sendResponse failed",s)}}),!0));w.tabs.onRemoved.addListener(e=>{E.handleTabRemoved(e).catch(t=>{p.error("tab removal handling failed",{tabId:e,error:t})})});async function _t(e,t,a,n){if(!a||typeof a!="object")return;const{type:s}=a;if(s==="TASKS_UPDATE"){try{J(a)}catch(o){t.warn("invalid TASKS_UPDATE payload",o);return}await e.handleTasksUpdate(a,n);return}if(s==="TASKS_HEARTBEAT"){try{Q(a)}catch(o){t.warn("invalid TASKS_HEARTBEAT payload",o);return}await e.handleHeartbeat(a,n);return}if(s==="POPUP_GET_STATE"){const o=await xt(e);return t.debug("popup state generated",{totalActive:o.totalActive}),o}t.debug("unknown message type ignored",{type:s})}function Rt(e){let t=!1;const n=v("codex-background",{debug:(...o)=>{t&&console.debug(...o)},info:(...o)=>console.info(...o),warn:(...o)=>console.warn(...o),error:(...o)=>console.error(...o)});s(),e.storage.onChanged.addListener((o,i)=>{if(i!=="session")return;const l=o[_];if(!l)return;const h=!!l.newValue;h!==t&&(t=h,n.info("verbose flag toggled",{verbose:t}))});async function s(){try{const i=!!(await e.storage.session.get({[_]:!1}))[_];i!==t&&(t=i,n.info("verbose flag toggled",{verbose:t}))}catch(o){console.warn("failed to read verbose flag",o)}}return{logger:n}}
