import{r as A,c as v,a as I,b as V,t as X,d as q,e as J,f as Q}from"../assets/chrome-CDKoC93C.js";import{c as tt}from"../assets/url-DdS-rsrb.js";import{S as R,l as et,g as at}from"../assets/messages-B9y2QbG0.js";function nt(){return"codex.tasks.state"}const N=12e3,$=15e3,st=3,O=nt(),K=3,ot=1e3;function rt(e={}){return new it(e)}class it{constructor(t){this.state=T(M),this.listeners=new Set,this.chrome=t.chrome??A();const a=t.logger??v("codex-background");this.logger=I(a,"aggregator"),this.now=t.now??(()=>Date.now()),this.ready=this.loadInitialState()}onStateChange(t){return this.listeners.add(t),()=>{this.listeners.delete(t)}}async getSnapshot(){return await this.ready,T(this.state)}async getTrackedTabIds(){return await this.ready,Object.keys(this.state.tabs).map(t=>Number(t))}async handleTasksUpdate(t,a){var s;await this.ready;const n=(s=a.tab)==null?void 0:s.id;if(typeof n!="number"){this.logger.warn("TASKS_UPDATE without tab id",{message:t});return}await this.updateState("tasks-update",(o,l)=>{const d=String(n),h=this.resolveTitle(a,t.origin),g=Object.prototype.hasOwnProperty.call((l==null?void 0:l.tabs)??{},d),r=o.tabs[d]??this.createTabState(t.origin,h,t.ts);let i=!g;r.origin!==t.origin&&(r.origin=t.origin,i=!0),r.title!==h&&(r.title=h,i=!0),r.count!==t.count&&(r.count=t.count,i=!0),r.active!==t.active&&(r.active=t.active,i=!0),r.updatedAt!==t.ts&&(r.updatedAt=t.ts,i=!0);const c=r.heartbeat,u=Math.max(c.lastReceivedAt,t.ts);c.lastReceivedAt!==u&&(c.lastReceivedAt=u,i=!0),c.status!=="OK"&&(c.status="OK",i=!0),c.missedCount!==0&&(c.missedCount=0,i=!0);const f=Math.max(u,r.lastSeenAt,t.ts);r.lastSeenAt!==f&&(r.lastSeenAt=f,i=!0);const m=t.signals.map(b=>({...b}));ft(r.signals,m)||(r.signals=m,i=!0),o.tabs[d]=r;const y=B(o.tabs);o.lastTotal!==y&&(o.lastTotal=y,i=!0);const x=(l==null?void 0:l.lastTotal)??0;return i=this.applyDebounceTransition(o,x)||i,i},{tabId:n}),this.logger.debug("TASKS_UPDATE processed",{tabId:n,count:t.count,active:t.active})}async handleHeartbeat(t,a){var s;await this.ready;const n=(s=a.tab)==null?void 0:s.id;if(typeof n!="number"){this.logger.warn("TASKS_HEARTBEAT without tab id",{message:t});return}await this.updateState("heartbeat",(o,l)=>{const d=String(n),h=this.resolveTitle(a,t.origin),g=Math.max(0,t.ts),r=Math.max(g,t.lastUpdateTs),i=Object.prototype.hasOwnProperty.call((l==null?void 0:l.tabs)??{},d),c=o.tabs[d]??this.createTabState(t.origin,h,r);let u=!i;c.origin!==t.origin&&(c.origin=t.origin,u=!0),c.title!==h&&(c.title=h,u=!0),c.updatedAt<r&&(c.updatedAt=r,u=!0);const f=c.heartbeat,m=Z(t.intervalMs);f.expectedIntervalMs!==m&&(f.expectedIntervalMs=m,u=!0),f.lastReceivedAt!==g&&(f.lastReceivedAt=g,u=!0),f.status!=="OK"&&(f.status="OK",u=!0),f.missedCount!==0&&(f.missedCount=0,u=!0);const y=Math.max(c.lastSeenAt,g,c.updatedAt);return c.lastSeenAt!==y&&(c.lastSeenAt=y,u=!0),o.tabs[d]=c,u},{tabId:n}),this.logger.debug("TASKS_HEARTBEAT processed",{tabId:n,intervalMs:t.intervalMs})}async handleTabRemoved(t){await this.ready,await this.updateState("tab-removed",a=>{const n=String(t);if(!(n in a.tabs))return!1;delete a.tabs[n];const s=B(a.tabs);return a.lastTotal!==s&&(a.lastTotal=s),s===0&&a.debounce.since!==0&&(a.debounce.since=0),!0},{tabId:t}),this.logger.info("tab removed",{tabId:t})}async evaluateHeartbeatStatuses(){await this.ready;const t=[];return await this.updateState("heartbeat-stale",a=>{let n=!1;const s=this.now();for(const[o,l]of Object.entries(a.tabs)){const{heartbeat:d}=l,h=d.expectedIntervalMs*st;s-d.lastReceivedAt>=h&&(t.push(Number(o)),d.status="STALE",d.missedCount+=1,n=!0)}return n},{staleTabIds:[...t]}),t.length>0&&this.logger.warn("heartbeat stale detected",{tabIds:t}),t}async clearDebounceIfIdle(){await this.ready;let t=!1;return await this.updateState("debounce-cleared",a=>a.debounce.since===0?!1:a.lastTotal===0&&ht(a.tabs)?(a.debounce.since=0,t=!0,!0):!1),t&&this.logger.info("debounce window cleared"),t}async loadInitialState(){try{const a=(await this.chrome.storage.session.get({[O]:M}))[O];if(a)try{V(a),this.state=T(ct(a)),this.logger.info("restored aggregated state",{tabs:Object.keys(this.state.tabs).length,lastTotal:this.state.lastTotal}),this.notifyListeners({reason:"init",previous:T(M),current:T(this.state)});return}catch(n){this.logger.warn("stored state invalid, resetting",n)}}catch(t){this.logger.error("failed to read storage",t)}this.state=T(M),await this.persistState(this.state),this.notifyListeners({reason:"init",previous:T(M),current:T(this.state)})}async updateState(t,a,n={}){const s=T(this.state),o=T(this.state);a(o,s)&&(W(o.debounce),V(o),await this.persistState(o),this.state=o,this.notifyListeners({reason:t,previous:s,current:T(this.state),...n}))}async persistState(t){const a={[O]:t};let n=0;for(;n<K;)try{await this.chrome.storage.session.set(a);return}catch(s){if(n+=1,this.logger.warn("failed to write state",{attempt:n,error:s}),n>=K)throw s;await gt(ot)}}notifyListeners(t){for(const a of Array.from(this.listeners))try{a({...t,previous:T(t.previous),current:T(t.current),staleTabIds:t.staleTabIds?[...t.staleTabIds]:void 0})}catch(n){this.logger.error("listener threw",n)}}applyDebounceTransition(t,a){const n=this.now();if(t.lastTotal===0){if(a>0&&t.debounce.since===0)return t.debounce.since=n,!0}else if(t.debounce.since!==0)return t.debounce.since=0,!0;return!1}resolveTitle(t,a){var o;const s=(((o=t.tab)==null?void 0:o.title)??"").trim();return s.length>0?s:a}createTabState(t,a,n){const s=Math.max(0,n);return{origin:t,title:a,count:0,active:!1,updatedAt:s,lastSeenAt:s,heartbeat:{lastReceivedAt:s,expectedIntervalMs:$,status:"OK",missedCount:0}}}}const M={tabs:{},lastTotal:0,debounce:{ms:N,since:0}};function W(e){(typeof e.ms!="number"||Number.isNaN(e.ms))&&(e.ms=N),e.ms=Math.min(Math.max(e.ms,0),6e4),(typeof e.since!="number"||Number.isNaN(e.since)||e.since<0)&&(e.since=0)}function ct(e){var a,n;const t={tabs:{},lastTotal:Math.max(0,e.lastTotal??0),debounce:{ms:((a=e.debounce)==null?void 0:a.ms)??N,since:((n=e.debounce)==null?void 0:n.since)??0}};for(const[s,o]of Object.entries(e.tabs??{}))t.tabs[s]=lt(o);return W(t.debounce),t}function lt(e){return{origin:e.origin,title:e.title,count:Math.max(0,e.count??0),active:!!e.active,updatedAt:e.updatedAt,lastSeenAt:e.lastSeenAt,heartbeat:ut(e.heartbeat),...e.signals?{signals:e.signals.map(t=>({...t}))}:{}}}function ut(e){return{lastReceivedAt:e.lastReceivedAt,expectedIntervalMs:Z(e.expectedIntervalMs),status:e.status==="STALE"?"STALE":"OK",missedCount:Math.max(0,e.missedCount??0)}}function T(e){const t={};for(const[a,n]of Object.entries(e.tabs))t[a]={origin:n.origin,title:n.title,count:n.count,active:n.active,updatedAt:n.updatedAt,lastSeenAt:n.lastSeenAt,heartbeat:{...n.heartbeat},...n.signals?{signals:n.signals.map(s=>({...s}))}:{}};return{tabs:t,lastTotal:e.lastTotal,debounce:{...e.debounce}}}function B(e){const t=new Map;for(const[n,s]of Object.entries(e)){const o=dt(s,n),l=t.get(o)??0,d=s.count>l?s.count:l;t.set(o,d)}let a=0;for(const n of t.values())a+=n;return a}function dt(e,t){const a=tt(e.origin);return a!=null&&a.isTasksListing?`listing:${a.canonical}`:`tab:${t}`}function ht(e){return Object.values(e).every(t=>t.count===0)}function ft(e,t){return!e&&!t?!0:!e||!t||e.length!==t.length?!1:e.every((a,n)=>{const s=t[n];return a.detector===s.detector&&a.evidence===s.evidence&&a.taskKey===s.taskKey})}function Z(e){return Number.isFinite(e)?Math.min(Math.max(Math.trunc(e),1e3),6e4):$}function gt(e){return new Promise(t=>{setTimeout(t,e)})}function U(e){var n,s,o;return(((s=(n=(e??A()).i18n)==null?void 0:n.getUILanguage)==null?void 0:s.call(n))??((o=globalThis.navigator)==null?void 0:o.language)??"en").toLowerCase().startsWith("ru")?"ru":"en"}const bt=[0,0,0,0],mt=200,P=9,H=[16,24,32],Tt=.92,D=[{threshold:0,color:"#16A34A"},{threshold:1,color:"#F97316"},{threshold:2,color:"#F2542D"},{threshold:3,color:"#E11D48"},{threshold:4,color:"#C2185B"}],j={en:e=>`${e} active Codex tasks`,ru:e=>`${e} активных задач Codex`};function pt(e,t={}){const a=t.chrome??A(),n=a.action,s=t.logger??v("codex-background"),o=I(s,"action-indicator");if(!n)return o.warn("chrome.action API is unavailable; badge indicator disabled"),{dispose(){}};let l=!1;const d=U(a),h=j[d]??j.en,g=z();g||o.debug("OffscreenCanvas/ImageData unavailable; falling back to badge text");const r=X(async u=>{if(l)return;const f=St(u.lastTotal??0);if(await c(()=>n.setBadgeBackgroundColor({color:bt})),await c(()=>n.setBadgeText({text:""})),n.setTitle&&await c(()=>n.setTitle({title:h(f.text)})),g&&n.setIcon){const m=At(f.text,f.color,o);m&&await c(()=>n.setIcon({imageData:m}))}else n.setBadgeTextColor&&(await c(()=>n.setBadgeTextColor({color:f.color})),await c(()=>n.setBadgeText({text:f.text})))},mt),i=e.onStateChange(u=>{r(u.current)});return e.ready.then(()=>e.getSnapshot()).then(u=>r(u)).catch(u=>{o.error("failed to apply initial badge state",u)}),{dispose(){var u;l=!0,i(),(u=r.cancel)==null||u.call(r)}};async function c(u){try{await u()}catch(f){o.warn("action API call failed",f)}}}function St(e){const t=Number.isFinite(e)?Math.max(0,Math.trunc(e)):0,a=t>P?String(P):String(t),n=yt(t);return{text:a,color:n}}function yt(e){for(let t=D.length-1;t>=0;t-=1){const a=D[t];if(e>=a.threshold)return a.color}return D[0].color}function z(){return typeof OffscreenCanvas<"u"&&typeof ImageData<"u"}function At(e,t,a){if(z())try{const n={};for(const s of H)n[s]=wt(s,e,t);return n}catch(n){return a.warn("failed to render text icon, falling back to transparent icon",n),vt(H)}}function wt(e,t,a){const s=new OffscreenCanvas(e,e).getContext("2d");if(!s)throw new Error("OffscreenCanvas context unavailable");s.clearRect(0,0,e,e),s.fillStyle=a,s.textAlign="center",s.textBaseline="middle";const o=Math.floor(e*Tt);s.font=`900 ${o}px "Inter","Segoe UI","Roboto",sans-serif`,s.lineJoin="round";const l=Math.max(1,Math.floor(e*.08));return s.strokeStyle="rgba(0,0,0,0.08)",s.lineWidth=l,s.strokeText(t,e/2,e/2),s.fillText(t,e/2,e/2),s.getImageData(0,0,e,e)}function vt(e){const t={};for(const a of e)t[a]=It(a);return t}function It(e){const t=e*e*4,a=new Uint8ClampedArray(t);return new ImageData(a,e,e)}function Et(e,t={}){const a=t.chrome??A(),n=I(t.logger??v("codex-background"),"audio-trigger"),s=new Ct(e,a,n);return{dispose(){s.dispose()}}}class Ct{constructor(t,a,n){this.aggregator=t,this.chrome=a,this.logger=n,this.disposed=!1,this.soundEnabled=R.sound,this.soundVolume=R.soundVolume,this.settingsInitialized=!1,this.unsubscribe=t.onStateChange(s=>{this.handleStateChange(s)}),this.storageListener=(s,o)=>{if(this.disposed||o!=="sync")return;const l={},d=s.sound;d&&typeof d.newValue=="boolean"&&(l.sound=d.newValue);const h=s.soundVolume;h&&typeof h.newValue=="number"&&(l.soundVolume=h.newValue),Object.keys(l).length>0&&this.applySettings(l)},this.chrome.storage.onChanged.addListener(this.storageListener),t.ready.catch(s=>{this.logger.warn("failed to init audio trigger state",s)}),this.refreshSettings()}dispose(){this.disposed||(this.disposed=!0,this.unsubscribe(),this.chrome.storage.onChanged.removeListener(this.storageListener))}async refreshSettings(){try{const t=await et(this.chrome);this.applySettings({sound:t.sound,soundVolume:t.soundVolume})}catch(t){this.logger.debug("failed to load audio settings",t)}}applySettings(t){let a=!this.settingsInitialized;if(typeof t.sound=="boolean"&&t.sound!==this.soundEnabled&&(this.soundEnabled=t.sound,a=!0),typeof t.soundVolume=="number"){const n=F(t.soundVolume);n!==this.soundVolume&&(this.soundVolume=n,a=!0)}this.settingsInitialized=!0,a&&this.broadcastSettingsUpdate()}async handleStateChange(t){if(this.disposed)return;const a=t.previous.lastTotal??0,n=t.current.lastTotal??0;a>0&&n===0&&await this.broadcastAudioChime()}async broadcastSettingsUpdate(){const t={type:"AUDIO_SETTINGS_UPDATE",sound:this.soundEnabled,soundVolume:this.soundVolume};await this.sendRuntimeMessage(t),await this.sendTabMessages(t)}async broadcastAudioChime(){if(!this.soundEnabled)return;const t=F(this.soundVolume);if(t<=0)return;const a={type:"AUDIO_CHIME",volume:t};await this.sendRuntimeMessage(a),await this.sendTabMessages(a)}async sendRuntimeMessage(t){try{await this.chrome.runtime.sendMessage(t)}catch(a){this.logger.debug("runtime audio message failed",a)}}async sendTabMessages(t){try{const a=await this.aggregator.getTrackedTabIds();await Promise.all(a.map(async n=>{try{await this.chrome.tabs.sendMessage(n,t)}catch(s){this.logger.debug("audio tab message failed",{tabId:n,error:s})}}))}catch(a){this.logger.debug("audio tab broadcast failed",a)}}}function F(e){return Number.isFinite(e)?e<=0?0:e>=1?1:e:R.soundVolume}async function Mt(e,t={}){var i;const a=await e.getSnapshot(),n=t.chrome??A(),s=t.locale??U(n),o=((i=t.now)==null?void 0:i.call(t))??Date.now(),l=new Date(o).toISOString(),d=xt(a).filter(c=>c.count>0);d.sort((c,u)=>{if(u.count!==c.count)return u.count-c.count;const f=c.lastSeenAt??0,m=u.lastSeenAt??0;return m!==f?m-f:u.tabId-c.tabId});const h=Math.max(0,d.reduce((c,u)=>c+u.count,0)),g={...at(s)},r={generatedAt:l,totalActive:h,tabs:d,locale:s,messages:g};return q(r),r}function xt(e){const t=[];for(const[a,n]of Object.entries(e.tabs)){const s=Number(a);Number.isFinite(s)&&t.push({tabId:s,title:n.title,origin:n.origin,count:Math.max(0,n.count),lastSeenAt:n.lastSeenAt,heartbeatStatus:n.heartbeat.status,signals:n.signals?n.signals.map(o=>({...o})):[]})}return t}const _="codex-poll",G=1;function Lt(e,t={}){const a=t.chrome??A(),n=t.logger??v("codex-background"),s=I(n,"alarms");a.alarms.create(_,{periodInMinutes:G}),s.info("alarm scheduled",{name:_,periodMinutes:G});const o=new Set,l=e.onStateChange(r=>{h(r.current).catch(i=>{s.warn("failed to enforce autoDiscardable",i)}),r.reason==="tab-removed"&&typeof r.tabId=="number"&&o.delete(r.tabId)});e.ready.then(()=>e.getSnapshot()).then(r=>h(r)).catch(r=>{s.error("failed to apply autoDiscardable on startup",r)}),e.getSnapshot().then(r=>h(r)).catch(r=>{s.warn("failed to apply autoDiscardable on initial snapshot",r)});const d=r=>{r.name===_&&g().catch(i=>{s.error("alarm tick failed",i)})};return a.alarms.onAlarm.addListener(d),{dispose(){a.alarms.onAlarm.removeListener(d),l(),o.clear()}};async function h(r){for(const i of Object.keys(r.tabs).map(Number))if(!o.has(i))try{await a.tabs.update(i,{autoDiscardable:!1}),o.add(i),s.debug("autoDiscardable disabled",{tabId:i})}catch(c){s.warn("autoDiscardable update failed",{tabId:i,error:c})}for(const i of Array.from(o))r.tabs[String(i)]||o.delete(i)}async function g(){s.debug("alarm tick");const r=await e.evaluateHeartbeatStatuses();if(r.length!==0)for(const i of r)try{await a.tabs.sendMessage(i,{type:"PING"}),s.info("ping sent to tab",{tabId:i})}catch(c){s.warn("failed to ping tab",{tabId:i,error:c})}}}const Y="codex-tasks-zero",Ot={en:{title:"Codex",message:"All Codex tasks are complete",buttonOk:"OK"},ru:{title:"Codex",message:"Все задачи Codex завершены",buttonOk:"ОК"}};function Dt(e,t={}){const a=t.chrome??A(),n=t.logger??v("codex-background"),s=I(n,"notifications"),o=t.now??(()=>Date.now()),l=U(a),d=Ot[l];let h=!1,g,r=0,i;const c=e.onStateChange(b=>{h||u(b.current).catch(S=>{s.error("state change handling failed",S)})});return e.ready.then(()=>e.getSnapshot()).then(b=>u(b)).catch(b=>{s.error("failed to read initial state",b)}),{dispose(){h=!0,g&&(clearTimeout(g),g=void 0),r=0,c()}};async function u(b){if(!h){if(b.lastTotal>0){m(),await x();return}if(b.debounce.since===0){m();return}f(b)}}function f(b){const S=b.debounce.since+b.debounce.ms,L=o();if(L>=S){y();return}if(g&&r===S)return;m();const C=Math.max(0,S-L);r=S,g=setTimeout(()=>{g=void 0,r=0,y()},C),s.debug("debounce timer scheduled",{delay:C,target:S})}function m(){g&&(clearTimeout(g),g=void 0),r=0}async function y(){if(h)return;const b=await e.getSnapshot();if(b.debounce.since===0){s.debug("debounce window already cleared");return}const S=b.debounce.since+b.debounce.ms;if(o()<S){s.debug("debounce window not ready yet"),f(b);return}if(b.lastTotal!==0||!_t(b)){s.info("activity detected during debounce, skipping notification"),m();return}try{i=await a.notifications.create(Y,{type:"basic",title:d.title,message:d.message,iconUrl:"assets/icon128.png",buttons:[{title:d.buttonOk}]})??Y,s.info("notification created",{notificationId:i})}catch(C){s.error("failed to create notification",C)}finally{m(),await e.clearDebounceIfIdle()}}async function x(){if(i){try{await a.notifications.clear(i),s.debug("notification cleared",{notificationId:i})}catch(b){s.warn("failed to clear notification",b)}i=void 0}}}function _t(e){return Object.values(e.tabs).every(t=>t.count===0)}const k="codex.tasks.verbose",w=A(),{logger:p}=Rt(w),E=rt({chrome:w,logger:p});Dt(E,{chrome:w,logger:p});pt(E,{chrome:w,logger:p});Et(E,{chrome:w,logger:p});Lt(E,{chrome:w,logger:p});w.runtime.onMessage.addListener((e,t,a)=>(kt(E,I(p,"runtime"),e,t).then(n=>{try{a(n)}catch(s){p.warn("sendResponse failed",s)}}).catch(n=>{p.error("message handling failed",n);try{a(void 0)}catch(s){p.warn("sendResponse failed",s)}}),!0));w.tabs.onRemoved.addListener(e=>{E.handleTabRemoved(e).catch(t=>{p.error("tab removal handling failed",{tabId:e,error:t})})});async function kt(e,t,a,n){if(!a||typeof a!="object")return;const{type:s}=a;if(s==="TASKS_UPDATE"){try{J(a)}catch(o){t.warn("invalid TASKS_UPDATE payload",o);return}await e.handleTasksUpdate(a,n);return}if(s==="TASKS_HEARTBEAT"){try{Q(a)}catch(o){t.warn("invalid TASKS_HEARTBEAT payload",o);return}await e.handleHeartbeat(a,n);return}if(s==="POPUP_GET_STATE"){const o=await Mt(e);return t.debug("popup state generated",{totalActive:o.totalActive}),o}t.debug("unknown message type ignored",{type:s})}function Rt(e){let t=!1;const n=v("codex-background",{debug:(...o)=>{t&&console.debug(...o)},info:(...o)=>console.info(...o),warn:(...o)=>console.warn(...o),error:(...o)=>console.error(...o)});s(),e.storage.onChanged.addListener((o,l)=>{if(l!=="session")return;const d=o[k];if(!d)return;const h=!!d.newValue;h!==t&&(t=h,n.info("verbose flag toggled",{verbose:t}))});async function s(){try{const l=!!(await e.storage.session.get({[k]:!1}))[k];l!==t&&(t=l,n.info("verbose flag toggled",{verbose:t}))}catch(o){console.warn("failed to read verbose flag",o)}}return{logger:n}}
