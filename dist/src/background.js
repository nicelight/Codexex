import{r as v,c as E,a as D,b as P,t as Q,d as tt,e as et,f as at}from"../assets/chrome-CWUhAqIv.js";import{c as U}from"../assets/url-odDJkPYl.js";import{S as B,l as nt,g as st}from"../assets/messages-OUg0OvmT.js";function ot(){return"codex.tasks.state"}const V=12e3,W=15e3,rt=3,k=ot(),F=3,it=1e3;function ct(e={}){return new lt(e)}class lt{constructor(t){this.state=S(O),this.listeners=new Set,this.chrome=t.chrome??v();const a=t.logger??E("codex-background");this.logger=D(a,"aggregator"),this.now=t.now??(()=>Date.now()),this.ready=this.loadInitialState()}onStateChange(t){return this.listeners.add(t),()=>{this.listeners.delete(t)}}async getSnapshot(){return await this.ready,S(this.state)}async getTrackedTabIds(){return await this.ready,Object.keys(this.state.tabs).map(t=>Number(t))}async handleTasksUpdate(t,a){var s;await this.ready;const n=(s=a.tab)==null?void 0:s.id;if(typeof n!="number"){this.logger.warn("TASKS_UPDATE without tab id",{message:t});return}await this.updateState("tasks-update",(o,r)=>{const l=String(n),g=Object.prototype.hasOwnProperty.call((r==null?void 0:r.tabs)??{},l),f=U(t.origin);if(!!!(f!=null&&f.isTasksListing||f!=null&&f.isTaskDetails)){let p=!1;l in o.tabs&&(delete o.tabs[l],p=!0);const w=L(o.tabs);o.lastTotal!==w&&(o.lastTotal=w,p=!0);const J=(r==null?void 0:r.lastTotal)??0;return p=this.applyDebounceTransition(o,J)||p,w===0&&o.debounce.since!==0&&x(o.tabs)&&(o.debounce.since=0,p=!0),p}const d=this.resolveTitle(a,t.origin),i=o.tabs[l]??this.createTabState(t.origin,d,t.ts);let c=!g;i.origin!==t.origin&&(i.origin=t.origin,c=!0),i.title!==d&&(i.title=d,c=!0),i.count!==t.count&&(i.count=t.count,c=!0),i.active!==t.active&&(i.active=t.active,c=!0),i.updatedAt!==t.ts&&(i.updatedAt=t.ts,c=!0);const h=i.heartbeat,T=Math.max(h.lastReceivedAt,t.ts);h.lastReceivedAt!==T&&(h.lastReceivedAt=T,c=!0),h.status!=="OK"&&(h.status="OK",c=!0),h.missedCount!==0&&(h.missedCount=0,c=!0);const y=Math.max(T,i.lastSeenAt,t.ts);i.lastSeenAt!==y&&(i.lastSeenAt=y,c=!0);const C=t.signals.map(p=>({...p}));ft(i.signals,C)||(i.signals=C,c=!0),o.tabs[l]=i;const b=L(o.tabs);o.lastTotal!==b&&(o.lastTotal=b,c=!0);const m=(r==null?void 0:r.lastTotal)??0;return c=this.applyDebounceTransition(o,m)||c,c},{tabId:n}),this.logger.debug("TASKS_UPDATE processed",{tabId:n,count:t.count,active:t.active})}async handleHeartbeat(t,a){var s;await this.ready;const n=(s=a.tab)==null?void 0:s.id;if(typeof n!="number"){this.logger.warn("TASKS_HEARTBEAT without tab id",{message:t});return}await this.updateState("heartbeat",(o,r)=>{const l=String(n),g=Object.prototype.hasOwnProperty.call((r==null?void 0:r.tabs)??{},l),f=U(t.origin);if(!!!(f!=null&&f.isTasksListing||f!=null&&f.isTaskDetails)){let m=!1;l in o.tabs&&(delete o.tabs[l],m=!0);const p=L(o.tabs);o.lastTotal!==p&&(o.lastTotal=p,m=!0);const w=(r==null?void 0:r.lastTotal)??0;return m=this.applyDebounceTransition(o,w)||m,p===0&&o.debounce.since!==0&&x(o.tabs)&&(o.debounce.since=0,m=!0),m}const d=this.resolveTitle(a,t.origin),i=Math.max(0,t.ts),c=Math.max(i,t.lastUpdateTs),h=o.tabs[l]??this.createTabState(t.origin,d,c);let T=!g;h.origin!==t.origin&&(h.origin=t.origin,T=!0),h.title!==d&&(h.title=d,T=!0),h.updatedAt<c&&(h.updatedAt=c,T=!0);const y=h.heartbeat,C=X(t.intervalMs);y.expectedIntervalMs!==C&&(y.expectedIntervalMs=C,T=!0),y.lastReceivedAt!==i&&(y.lastReceivedAt=i,T=!0),y.status!=="OK"&&(y.status="OK",T=!0),y.missedCount!==0&&(y.missedCount=0,T=!0);const b=Math.max(h.lastSeenAt,i,h.updatedAt);return h.lastSeenAt!==b&&(h.lastSeenAt=b,T=!0),o.tabs[l]=h,T},{tabId:n}),this.logger.debug("TASKS_HEARTBEAT processed",{tabId:n,intervalMs:t.intervalMs})}async handleTabRemoved(t){await this.ready,await this.updateState("tab-removed",a=>{const n=String(t);if(!(n in a.tabs))return!1;delete a.tabs[n];const s=L(a.tabs);return a.lastTotal!==s&&(a.lastTotal=s),s===0&&a.debounce.since!==0&&(a.debounce.since=0),!0},{tabId:t}),this.logger.info("tab removed",{tabId:t})}async evaluateHeartbeatStatuses(){await this.ready;const t=[];return await this.updateState("heartbeat-stale",a=>{let n=!1;const s=this.now();for(const[o,r]of Object.entries(a.tabs)){const{heartbeat:l}=r,g=l.expectedIntervalMs*rt;s-l.lastReceivedAt>=g&&(t.push(Number(o)),l.status="STALE",l.missedCount+=1,n=!0)}return n},{staleTabIds:[...t]}),t.length>0&&this.logger.warn("heartbeat stale detected",{tabIds:t}),t}async clearDebounceIfIdle(){await this.ready;let t=!1;return await this.updateState("debounce-cleared",a=>a.debounce.since===0?!1:a.lastTotal===0&&x(a.tabs)?(a.debounce.since=0,t=!0,!0):!1),t&&this.logger.info("debounce window cleared"),t}async loadInitialState(){try{const a=(await this.chrome.storage.session.get({[k]:O}))[k];if(a)try{P(a),this.state=S(ut(a)),this.logger.info("restored aggregated state",{tabs:Object.keys(this.state.tabs).length,lastTotal:this.state.lastTotal}),this.notifyListeners({reason:"init",previous:S(O),current:S(this.state)});return}catch(n){this.logger.warn("stored state invalid, resetting",n)}}catch(t){this.logger.error("failed to read storage",t)}this.state=S(O),await this.persistState(this.state),this.notifyListeners({reason:"init",previous:S(O),current:S(this.state)})}async updateState(t,a,n={}){const s=S(this.state),o=S(this.state);a(o,s)&&(Z(o.debounce),P(o),await this.persistState(o),this.state=o,this.notifyListeners({reason:t,previous:s,current:S(this.state),...n}))}async persistState(t){const a={[k]:t};let n=0;for(;n<F;)try{await this.chrome.storage.session.set(a);return}catch(s){if(n+=1,this.logger.warn("failed to write state",{attempt:n,error:s}),n>=F)throw s;await gt(it)}}notifyListeners(t){for(const a of Array.from(this.listeners))try{a({...t,previous:S(t.previous),current:S(t.current),staleTabIds:t.staleTabIds?[...t.staleTabIds]:void 0})}catch(n){this.logger.error("listener threw",n)}}applyDebounceTransition(t,a){const n=this.now();if(t.lastTotal===0){if(a>0&&t.debounce.since===0)return t.debounce.since=n,!0}else if(t.debounce.since!==0)return t.debounce.since=0,!0;return!1}resolveTitle(t,a){var o;const s=(((o=t.tab)==null?void 0:o.title)??"").trim();return s.length>0?s:a}createTabState(t,a,n){const s=Math.max(0,n);return{origin:t,title:a,count:0,active:!1,updatedAt:s,lastSeenAt:s,heartbeat:{lastReceivedAt:s,expectedIntervalMs:W,status:"OK",missedCount:0}}}}const O={tabs:{},lastTotal:0,debounce:{ms:V,since:0}};function Z(e){(typeof e.ms!="number"||Number.isNaN(e.ms))&&(e.ms=V),e.ms=Math.min(Math.max(e.ms,0),6e4),(typeof e.since!="number"||Number.isNaN(e.since)||e.since<0)&&(e.since=0)}function ut(e){var n,s;const t={};for(const[o,r]of Object.entries(e.tabs??{}))t[o]=dt(r);const a={tabs:t,lastTotal:L(t),debounce:{ms:((n=e.debounce)==null?void 0:n.ms)??V,since:((s=e.debounce)==null?void 0:s.since)??0}};return Z(a.debounce),a}function dt(e){return{origin:e.origin,title:e.title,count:Math.max(0,e.count??0),active:!!e.active,updatedAt:e.updatedAt,lastSeenAt:e.lastSeenAt,heartbeat:ht(e.heartbeat),...e.signals?{signals:e.signals.map(t=>({...t}))}:{}}}function ht(e){return{lastReceivedAt:e.lastReceivedAt,expectedIntervalMs:X(e.expectedIntervalMs),status:e.status==="STALE"?"STALE":"OK",missedCount:Math.max(0,e.missedCount??0)}}function S(e){const t={};for(const[a,n]of Object.entries(e.tabs))t[a]={origin:n.origin,title:n.title,count:n.count,active:n.active,updatedAt:n.updatedAt,lastSeenAt:n.lastSeenAt,heartbeat:{...n.heartbeat},...n.signals?{signals:n.signals.map(s=>({...s}))}:{}};return{tabs:t,lastTotal:e.lastTotal,debounce:{...e.debounce}}}function L(e){const t=new Map;let a=0,n=!1,s=0;for(const o of Object.values(e)){const r=U(o.origin);if(r!=null&&r.isTasksListing){const l=r.canonical,g=t.get(l)??0,f=o.count>g?o.count:g;t.set(l,f);continue}if(r!=null&&r.isTaskDetails){n=!0,a=Math.max(a,o.count);continue}s+=o.count}if(n)return a;if(t.size>0){let o=0;for(const r of t.values())o+=r;return o}return s}function x(e){return Object.values(e).every(t=>t.count===0)}function ft(e,t){return!e&&!t?!0:!e||!t||e.length!==t.length?!1:e.every((a,n)=>{const s=t[n];return a.detector===s.detector&&a.evidence===s.evidence&&a.taskKey===s.taskKey})}function X(e){return Number.isFinite(e)?Math.min(Math.max(Math.trunc(e),1e3),6e4):W}function gt(e){return new Promise(t=>{setTimeout(t,e)})}function K(e){var n,s,o;return(((s=(n=(e??v()).i18n)==null?void 0:n.getUILanguage)==null?void 0:s.call(n))??((o=globalThis.navigator)==null?void 0:o.language)??"en").toLowerCase().startsWith("ru")?"ru":"en"}const bt=[0,0,0,0],Tt=200,j=9,H=[16,24,32],mt=.92,_=[{threshold:0,color:"#16A34A"},{threshold:1,color:"#F97316"},{threshold:2,color:"#F2542D"},{threshold:3,color:"#E11D48"},{threshold:4,color:"#C2185B"}],pt="#7C3AED",G={en:e=>`${e} active Codex tasks`,ru:e=>`${e} активных задач Codex`};function yt(e,t={}){const a=t.chrome??v(),n=a.action,s=t.logger??E("codex-background"),o=D(s,"action-indicator");if(!n)return o.warn("chrome.action API is unavailable; badge indicator disabled"),{dispose(){}};let r=!1;const l=K(a),g=G[l]??G.en,f=q();f||o.debug("OffscreenCanvas/ImageData unavailable; falling back to badge text");const u=Q(async c=>{if(r)return;const h=St(c.lastTotal??0,{hasCodexTabs:Object.keys(c.tabs).length>0});if(await i(()=>n.setBadgeBackgroundColor({color:bt})),await i(()=>n.setBadgeText({text:""})),n.setTitle&&await i(()=>n.setTitle({title:g(h.text)})),f&&n.setIcon){const T=At(h.text,h.color,o);T&&await i(()=>n.setIcon({imageData:T}))}else n.setBadgeTextColor&&(await i(()=>n.setBadgeTextColor({color:h.color})),await i(()=>n.setBadgeText({text:h.text})))},Tt),d=e.onStateChange(c=>{u(c.current)});return e.ready.then(()=>e.getSnapshot()).then(c=>u(c)).catch(c=>{o.error("failed to apply initial badge state",c)}),{dispose(){var c;r=!0,d(),(c=u.cancel)==null||c.call(u)}};async function i(c){try{await c()}catch(h){o.warn("action API call failed",h)}}}function St(e,t={}){const a=Number.isFinite(e)?Math.max(0,Math.trunc(e)):0;if(!(t.hasCodexTabs??!0)&&a===0)return{text:"0",color:pt};const s=a>j?String(j):String(a),o=wt(a);return{text:s,color:o}}function wt(e){for(let t=_.length-1;t>=0;t-=1){const a=_[t];if(e>=a.threshold)return a.color}return _[0].color}function q(){return typeof OffscreenCanvas<"u"&&typeof ImageData<"u"}function At(e,t,a){if(q())try{const n={};for(const s of H)n[s]=vt(s,e,t);return n}catch(n){return a.warn("failed to render text icon, falling back to transparent icon",n),It(H)}}function vt(e,t,a){const s=new OffscreenCanvas(e,e).getContext("2d");if(!s)throw new Error("OffscreenCanvas context unavailable");s.clearRect(0,0,e,e),s.fillStyle=a,s.textAlign="center",s.textBaseline="middle";const o=Math.floor(e*mt);s.font=`900 ${o}px "Inter","Segoe UI","Roboto",sans-serif`,s.lineJoin="round";const r=Math.max(1,Math.floor(e*.08));return s.strokeStyle="rgba(0,0,0,0.08)",s.lineWidth=r,s.strokeText(t,e/2,e/2),s.fillText(t,e/2,e/2),s.getImageData(0,0,e,e)}function It(e){const t={};for(const a of e)t[a]=Ct(a);return t}function Ct(e){const t=e*e*4,a=new Uint8ClampedArray(t);return new ImageData(a,e,e)}function Et(e,t={}){const a=t.chrome??v(),n=D(t.logger??E("codex-background"),"audio-trigger"),s=new Dt(e,a,n);return{dispose(){s.dispose()}}}class Dt{constructor(t,a,n){this.aggregator=t,this.chrome=a,this.logger=n,this.disposed=!1,this.soundEnabled=B.sound,this.soundVolume=B.soundVolume,this.settingsInitialized=!1,this.waitingForIdle=!1,this.debounceTarget=0,this.unsubscribe=t.onStateChange(s=>{this.handleStateChange(s)}),this.storageListener=(s,o)=>{if(this.disposed||o!=="sync")return;const r={},l=s.sound;l&&typeof l.newValue=="boolean"&&(r.sound=l.newValue);const g=s.soundVolume;g&&typeof g.newValue=="number"&&(r.soundVolume=g.newValue),Object.keys(r).length>0&&this.applySettings(r)},this.chrome.storage.onChanged.addListener(this.storageListener),t.ready.catch(s=>{this.logger.warn("failed to init audio trigger state",s)}),this.refreshSettings()}dispose(){this.disposed||(this.disposed=!0,this.unsubscribe(),this.chrome.storage.onChanged.removeListener(this.storageListener),this.clearDebounceTimer())}async refreshSettings(){try{const t=await nt(this.chrome);this.applySettings({sound:t.sound,soundVolume:t.soundVolume})}catch(t){this.logger.debug("failed to load audio settings",t)}}applySettings(t){let a=!this.settingsInitialized;if(typeof t.sound=="boolean"&&t.sound!==this.soundEnabled&&(this.soundEnabled=t.sound,a=!0),typeof t.soundVolume=="number"){const n=z(t.soundVolume);n!==this.soundVolume&&(this.soundVolume=n,a=!0)}this.settingsInitialized=!0,a&&this.broadcastSettingsUpdate()}async handleStateChange(t){if(this.disposed)return;const a=t.previous.lastTotal??0,n=t.current.lastTotal??0;if(n>0){this.waitingForIdle=!1,this.clearDebounceTimer();return}if(a>0&&n===0){this.waitingForIdle=!0,await this.tryTriggerChime(t.current);return}this.waitingForIdle&&n===0&&await this.tryTriggerChime(t.current)}async broadcastSettingsUpdate(){const t={type:"AUDIO_SETTINGS_UPDATE",sound:this.soundEnabled,soundVolume:this.soundVolume};await this.sendRuntimeMessage(t),await this.sendTabMessages(t)}async broadcastAudioChime(){if(!this.soundEnabled)return;const t=z(this.soundVolume);if(t<=0)return;const a={type:"AUDIO_CHIME",volume:t};await this.sendRuntimeMessage(a),await this.sendTabMessages(a)}async tryTriggerChime(t){if(this.disposed||!this.waitingForIdle)return;const a=t??await this.aggregator.getSnapshot();if(a.lastTotal!==0||!Mt(a)){this.waitingForIdle=!1,this.clearDebounceTimer();return}if(a.debounce.since===0){this.waitingForIdle=!1,this.clearDebounceTimer(),await this.broadcastAudioChime();return}const n=a.debounce.since+a.debounce.ms,s=Date.now();if(s>=n){this.waitingForIdle=!1,this.clearDebounceTimer(),await this.broadcastAudioChime();return}this.scheduleDebounceTimer(n,s)}scheduleDebounceTimer(t,a){if(this.debounceTimer&&this.debounceTarget===t)return;this.clearDebounceTimer();const n=Math.max(0,t-a);this.debounceTarget=t,this.debounceTimer=setTimeout(()=>{this.debounceTimer=void 0,this.debounceTarget=0,this.tryTriggerChime()},n)}clearDebounceTimer(){this.debounceTimer&&(clearTimeout(this.debounceTimer),this.debounceTimer=void 0),this.debounceTarget=0}async sendRuntimeMessage(t){try{await this.chrome.runtime.sendMessage(t)}catch(a){this.logger.debug("runtime audio message failed",a)}}async sendTabMessages(t){try{const a=await this.aggregator.getTrackedTabIds();await Promise.all(a.map(async n=>{try{await this.chrome.tabs.sendMessage(n,t)}catch(s){this.logger.debug("audio tab message failed",{tabId:n,error:s})}}))}catch(a){this.logger.debug("audio tab broadcast failed",a)}}}function z(e){return Number.isFinite(e)?e<=0?0:e>=1?1:e:B.soundVolume}function Mt(e){return Object.values(e.tabs).every(t=>t.count===0)}async function Ot(e,t={}){var d;const a=await e.getSnapshot(),n=t.chrome??v(),s=t.locale??K(n),o=((d=t.now)==null?void 0:d.call(t))??Date.now(),r=new Date(o).toISOString(),l=kt(a).filter(i=>i.count>0);l.sort((i,c)=>{if(c.count!==i.count)return c.count-i.count;const h=i.lastSeenAt??0,T=c.lastSeenAt??0;return T!==h?T-h:c.tabId-i.tabId});const g=Lt(a.lastTotal),f={...st(s)},u={generatedAt:r,totalActive:g,tabs:l,locale:s,messages:f};return tt(u),u}function Lt(e){return Number.isFinite(e)?Math.max(0,Math.trunc(e)):0}function kt(e){const t=[];for(const[a,n]of Object.entries(e.tabs)){const s=Number(a);Number.isFinite(s)&&t.push({tabId:s,title:n.title,origin:n.origin,count:Math.max(0,n.count),lastSeenAt:n.lastSeenAt,heartbeatStatus:n.heartbeat.status,signals:n.signals?n.signals.map(o=>({...o})):[]})}return t}const R="codex-poll",Y=1;function xt(e,t={}){const a=t.chrome??v(),n=t.logger??E("codex-background"),s=D(n,"alarms");a.alarms.create(R,{periodInMinutes:Y}),s.info("alarm scheduled",{name:R,periodMinutes:Y});const o=new Set,r=e.onStateChange(u=>{g(u.current).catch(d=>{s.warn("failed to enforce autoDiscardable",d)}),u.reason==="tab-removed"&&typeof u.tabId=="number"&&o.delete(u.tabId)});e.ready.then(()=>e.getSnapshot()).then(u=>g(u)).catch(u=>{s.error("failed to apply autoDiscardable on startup",u)}),e.getSnapshot().then(u=>g(u)).catch(u=>{s.warn("failed to apply autoDiscardable on initial snapshot",u)});const l=u=>{u.name===R&&f().catch(d=>{s.error("alarm tick failed",d)})};return a.alarms.onAlarm.addListener(l),{dispose(){a.alarms.onAlarm.removeListener(l),r(),o.clear()}};async function g(u){for(const d of Object.keys(u.tabs).map(Number))if(!o.has(d))try{await a.tabs.update(d,{autoDiscardable:!1}),o.add(d),s.debug("autoDiscardable disabled",{tabId:d})}catch(i){s.warn("autoDiscardable update failed",{tabId:d,error:i})}for(const d of Array.from(o))u.tabs[String(d)]||o.delete(d)}async function f(){s.debug("alarm tick");const u=await e.evaluateHeartbeatStatuses();if(u.length!==0)for(const d of u)try{await a.tabs.sendMessage(d,{type:"PING"}),s.info("ping sent to tab",{tabId:d})}catch(i){s.warn("failed to ping tab",{tabId:d,error:i})}}}const $="codex-tasks-zero",_t={en:{title:"Codex",message:"All Codex tasks are complete",buttonOk:"OK"},ru:{title:"Codex",message:"Все задачи Codex завершены",buttonOk:"ОК"}};function Rt(e,t={}){const a=t.chrome??v(),n=t.logger??E("codex-background"),s=D(n,"notifications"),o=t.now??(()=>Date.now()),r=K(a),l=_t[r];let g=!1,f,u=0,d;const i=e.onStateChange(b=>{g||c(b.current).catch(m=>{s.error("state change handling failed",m)})});return e.ready.then(()=>e.getSnapshot()).then(b=>c(b)).catch(b=>{s.error("failed to read initial state",b)}),{dispose(){g=!0,f&&(clearTimeout(f),f=void 0),u=0,i()}};async function c(b){if(!g){if(b.lastTotal>0){T(),await C();return}if(b.debounce.since===0){T();return}h(b)}}function h(b){const m=b.debounce.since+b.debounce.ms,p=o();if(p>=m){y();return}if(f&&u===m)return;T();const w=Math.max(0,m-p);u=m,f=setTimeout(()=>{f=void 0,u=0,y()},w),s.debug("debounce timer scheduled",{delay:w,target:m})}function T(){f&&(clearTimeout(f),f=void 0),u=0}async function y(){if(g)return;const b=await e.getSnapshot();if(b.debounce.since===0){s.debug("debounce window already cleared");return}const m=b.debounce.since+b.debounce.ms;if(o()<m){s.debug("debounce window not ready yet"),h(b);return}if(b.lastTotal!==0||!Nt(b)){s.info("activity detected during debounce, skipping notification"),T();return}try{d=await a.notifications.create($,{type:"basic",title:l.title,message:l.message,iconUrl:"assets/icon128.png",buttons:[{title:l.buttonOk}]})??$,s.info("notification created",{notificationId:d})}catch(w){s.error("failed to create notification",w)}finally{T(),await e.clearDebounceIfIdle()}}async function C(){if(d){try{await a.notifications.clear(d),s.debug("notification cleared",{notificationId:d})}catch(b){s.warn("failed to clear notification",b)}d=void 0}}}function Nt(e){return Object.values(e.tabs).every(t=>t.count===0)}const N="codex.tasks.verbose",I=v(),{logger:A}=Bt(I),M=ct({chrome:I,logger:A});Rt(M,{chrome:I,logger:A});yt(M,{chrome:I,logger:A});Et(M,{chrome:I,logger:A});xt(M,{chrome:I,logger:A});I.runtime.onMessage.addListener((e,t,a)=>(Ut(M,D(A,"runtime"),e,t).then(n=>{try{a(n)}catch(s){A.warn("sendResponse failed",s)}}).catch(n=>{A.error("message handling failed",n);try{a(void 0)}catch(s){A.warn("sendResponse failed",s)}}),!0));I.tabs.onRemoved.addListener(e=>{M.handleTabRemoved(e).catch(t=>{A.error("tab removal handling failed",{tabId:e,error:t})})});async function Ut(e,t,a,n){if(!a||typeof a!="object")return;const{type:s}=a;if(s==="TASKS_UPDATE"){try{et(a)}catch(o){t.warn("invalid TASKS_UPDATE payload",o);return}await e.handleTasksUpdate(a,n);return}if(s==="TASKS_HEARTBEAT"){try{at(a)}catch(o){t.warn("invalid TASKS_HEARTBEAT payload",o);return}await e.handleHeartbeat(a,n);return}if(s==="POPUP_GET_STATE"){const o=await Ot(e);return t.debug("popup state generated",{totalActive:o.totalActive}),o}t.debug("unknown message type ignored",{type:s})}function Bt(e){let t=!1;const n=E("codex-background",{debug:(...o)=>{t&&console.debug(...o)},info:(...o)=>console.info(...o),warn:(...o)=>console.warn(...o),error:(...o)=>console.error(...o)});s(),e.storage.onChanged.addListener((o,r)=>{if(r!=="session")return;const l=o[N];if(!l)return;const g=!!l.newValue;g!==t&&(t=g,n.info("verbose flag toggled",{verbose:t}))});async function s(){try{const r=!!(await e.storage.session.get({[N]:!1}))[N];r!==t&&(t=r,n.info("verbose flag toggled",{verbose:t}))}catch(o){console.warn("failed to read verbose flag",o)}}return{logger:n}}
