# Roadmap: Spec Package Delivery

> Следуем Spec-Driven Development: выполняем задачи последовательно, не приступаем к реализации, пока не завершён весь необходимый объём спецификаций.

## Структура работ

| № | Этап | Цель и ключевые действия | Артефакты | Статус |
|---|------|---------------------------|-----------|--------|
| 1 | Анализ брифа и существующих материалов | Подтвердить понимание контекста, ограничений и целевых платформ. Зафиксировать исходные требования, выявить пробелы. | Отчёт о анализе (summary) в `spec/context.md` | ☑ DONE |
| 2 | Scope & Stakeholders | Уточнить персоны, акторов, внешние зависимости, границы системы. | Раздел «Stakeholders & Scope» в `spec/context.md` | ☑ DONE |
| 3 | Domain Glossary | Сформировать словарь ключевых терминов и сущностей, согласовать названия. | `spec/domain-glossary.md` | ☑ DONE |
| 4 | Use Cases & User Journeys | Описать основные и альтернативные сценарии, предусловия/постусловия. | `spec/use-cases.md` с минимум 3 сценариями | ☑ DONE |
| 5 | Системные функции и состояния | Разбить на capabilities/функциональные требования; описать состояния и триггеры. | `spec/system-capabilities.md` | ☑ DONE |
| 6 | Детекторы и сигналы | Формализовать детекторы DOM/событий, их приоритеты, стратегии антидребезга. | `spec/detectors.md` | ☑ DONE |
| 7 | NFR и эксплуатационные требования | Зафиксировать производительность, надёжность, безопасность, UX-ограничения, политику хранения данных. | `spec/nfr.md` | ☑ DONE |
| 8 | Контракты обмена данными | Детализировать DTO, события, состояния. Разработать JSON Schema для сообщений и хранения. | JSON Schema файлы в `contracts/` (например, `contracts/dto/content-update.schema.json`) | ☑ DONE |
| 9 | OpenAPI спецификация | Сформировать OpenAPI для публичных/внутренних точек расширения (если необходимы), включить модели. | `contracts/openapi.yaml` | ☑ DONE |
|10 | Диаграммы последовательностей и состояний | Описать ключевые потоки: обнаружение задач, агрегация, выдача уведомления. | Mermaid-диаграммы в `spec/diagrams/*.md` | ☑ DONE |
|11 | Acceptance Criteria & Test Plan | Определить проверяемые условия, позитивные/негативные кейсы, контрактные тесты. | `spec/test-plan.md` | ☑ DONE |
|12 | План реализации (Skeleton Outline) | Подготовить структуру каталогов, роли скриптов, зависимости. | `spec/implementation-plan.md` | ☑ DONE |
|13 | Review & Sign-off | Провести самопроверку соответствия брифу, выявить риски, подготовить summary для утверждения. | Checklist и выводы в `spec/review.md` | ☑ DONE |

## Правила выполнения

1. Работать строго последовательно по таблице. Переход на следующий этап только после фиксации артефактов текущего.
2. Все артефакты хранить в Markdown/JSON, следуя структуре каталогов.
3. Любые новые вопросы или неоднозначности документировать и эскалировать до их разрешения.
4. После завершения этапа обновлять статус (☑ DONE) и при необходимости ссылаться на связанные документы.
5. Перед началом реализации убедиться, что чек-лист SDD (контракты, NFR, диаграммы, тест-план) полностью закрыт.

---

# Roadmap: Реализация кода (v0.1.0)

> Отправная точка — полный пакет спецификаций (см. таблицу выше). Ниже перечислены шаги для реализации расширения Chrome с учётом зависимостей и ожидаемых артефактов.

## Фаза 0. Подготовка инфраструктуры проекта ⏳

- [ ] **Инициализация репозитория под сборку MV3**
  - [ ] Создать `package.json`, подключить `vite`, `typescript`, `vitest`, `@types/chrome`, `@webext-core/mv3-vite` (либо аналогичный плагин) согласно `spec/implementation-plan.md`.
  - [ ] Настроить `tsconfig.json` с alias для `src/*`, включить строгий режим типов.
  - [ ] Добавить базовую структуру каталогов `/extension/src/...` и конфиги форматирования (Prettier/ESLint при необходимости).
- [ ] **Manifest & build pipeline**
  - [ ] Создать `manifest.json` (MV3) с минимальными разрешениями (`notifications`, `alarms`, `storage`, `tabs`, `scripting`, `host_permissions`).
  - [ ] Настроить `vite.config.ts` для сборки background service worker, content-script и popup.
  - [ ] Добавить npm-скрипты: `build`, `dev`, `lint` (если применимо), `test:unit`, `test:contract`, `test:integration`.

## Фаза 1. Общие модули и контракты ⏳

- [ ] **Генерация типов и валидация**
  - [ ] Реализовать скрипт генерации типов из JSON Schema в `src/shared/contracts.ts` (использовать `json-schema-to-typescript` или альтернативу).
  - [ ] Настроить runtime-валидацию DTO и состояния с помощью `ajv` (dev-зависимость), экспортировать helper-функции.
- [ ] **Адаптер Chrome API**
  - [ ] Создать thin-wrapper в `src/shared/chrome.ts` с типами и мок-стабами для тестов.
  - [ ] Определить общий интерфейс логирования и утилиты времени (throttle/debounce, `requestIdleCallback` полифилл для тестов).

## Фаза 2. Content-script ⏳

- [ ] **Детекторы активных задач**
  - [ ] Реализовать модульную архитектуру детекторов в `src/content/detectors/*` для D1 (spinner) и D2 (Stop button).
  - [ ] Написать unit-тесты на фикстурах DOM для каждого детектора, проверить RU/EN подписи.
- [ ] **Агрегация сигналов**
  - [ ] Объединить сигналы, вычислять `count` и формировать DTO `TASKS_UPDATE` согласно контракту для последующей передачи в background.
  - [ ] Настроить throttle/anti-bounce отправки (используя `requestIdleCallback`/таймеры) и зафиксировать параметры debounce, которые будет учитывать background.
- [ ] **Взаимодействие с background**
  - [ ] Обрабатывать входящие `PING`/`RESET` (если потребуется) сообщения.
  - [ ] Интегрировать fail-safe таймер на случай отсутствия мутаций (периодическая проверка DOM) и документировать формат heartbeat для агрегатора.

## Фаза 3. Background service worker ⏳

- [ ] **Обработка входящих сообщений**
  - [ ] В `src/background/index.ts` зарегистрировать listeners (`chrome.runtime.onMessage`, `chrome.tabs.onRemoved`, `chrome.runtime.onInstalled`).
  - [ ] Организовать маршрутизацию сообщений: `TASKS_UPDATE` от контент-скрипта, `PING`, запрос состояния popup.
- [ ] **Агрегация состояния**
  - [ ] Реализовать `aggregator.ts` для обработки DTO `TASKS_UPDATE`, обновления `storage.session.state` по схеме `codex.tasks/state/session.json` и хранения heartbeat из контент-скрипта.
  - [ ] Поддерживать консистентность `tabs` при закрытии вкладок и рестарте service worker, переиспользуя идентификаторы вкладок, которые публикует контент-скрипт.
  - [ ] Добавить повторную запись состояния при ошибках `chrome.storage.session` с таймером ≈1 с, покрыть обработку `chrome.runtime.lastError` unit-тестами; шаг закрывает требование Reliability в `spec/nfr.md`.
- [ ] **Уведомления и антидребезг**
  - [ ] Создать модуль `notifications.ts`, учитывающий `debounceMs`/heartbeat, которые поставляет контент-скрипт, для детекции перехода `totalActiveCount` от >0 к 0.
  - [ ] Инкапсулировать логику одиночного уведомления и очистку уведомлений при новых задачах.
  - [ ] Вынести тексты уведомлений в i18n-слой, выбирать локаль по настройкам браузера и обеспечивать RU/EN варианты.
- [ ] **Алгоритм будильников**
  - [ ] Реализовать `alarms.ts` с расписанием `chrome.alarms` и обработчиком повторных `PING` во вкладки, используя контент-скриптовый heartbeat как признак активности.
  - [ ] Добавить применение `autoDiscardableOff` ко вкладкам Codex после обновления состояния.

## Фаза 4. Popup UI ⏳

- [ ] **Интеграция со state**
  - [ ] Создать адаптер, запрашивающий агрегированное состояние у background (`chrome.runtime.sendMessage`).
  - [ ] Реализовать отображение списка вкладок/сигналов и fallback «Нет активных задач».
- [ ] **UX и локализация**
  - [ ] Добавить базовый стиль (CSS/HTMX шаблоны), обеспечить поддержку RU/EN текстов.
  - [ ] Покрыть рендер unit-тестами (jsdom/snapshots) и проверить устойчивость к пустым/большим спискам.

## Фаза 5. Тестирование и качество ⏳

- [ ] **Unit tests**
  - [ ] Покрыть детекторы, агрегатор, уведомления, storage helper'ы (`vitest`).
  - [ ] Использовать мок Chrome API для воспроизведения сценариев.
  - [ ] Запланировать unit- или контрактный тест, подтверждающий корректное переключение RU/EN уведомлений согласно требованию «Уведомления формулируются на языке интерфейса браузера» из `spec/nfr.md`.
- [ ] **Contract tests**
  - [ ] Проверить соответствие DTO и state JSON Schema (`ajv`/`schemathesis`).
  - [ ] Валидировать OpenAPI (`contracts/openapi.yaml`) против реализованных эндпоинтов/background-хендлеров.
- [ ] **Локальный HTTP-адаптер для тестов**
  - [ ] Реализовать `msw` (или аналогичный) адаптер, эмулирующий маршруты `/background/tasks-update`, `/background/state`, `/popup/state`.
  - [ ] Переиспользовать текущие background/popup-хендлеры и подключить контрактные проверки по `contracts/openapi.yaml` и схемам DTO/State/Settings согласно требованиям `spec/test-plan.md` и `spec/implementation-plan.md`.
- [ ] **Integration tests**
  - [ ] Смоделировать ключевые use-cases (UC-1..UC-3 из `spec/use-cases.md`) с фейковым DOM и обменом сообщениями.
  - [ ] Проверить устойчивость к перезапуску service worker и закрытию вкладок.

## Фаза 6. Документация, упаковка и QA ⏳

- [ ] **Документация**
  - [ ] Обновить `README.md` инструкциями по сборке (`npm install`, `npm run build`, установка unpacked расширения).
  - [ ] Зафиксировать Known Issues и TODO для релиза v0.2.0 (настройки, бейдж, звук).
- [ ] **Сборка и ручное тестирование**
  - [ ] Подготовить production build и проверить в Chrome (режим разработчика).
  - [ ] Провести смоук-тесты: одиночная вкладка, несколько вкладок, сон service worker.
- [ ] **Готовность к релизу**
  - [ ] Собрать пакет для Chrome Web Store (zip), убедиться в соответствии требованиям (раздел «Критерии готовности» в `spec/implementation-plan.md`).
  - [ ] Сформировать CHANGELOG и план следующих итераций (v0.2.0).
